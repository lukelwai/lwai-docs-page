(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{458:function(_,a,v){"use strict";v.r(a);var t=v(2),s=Object(t.a)({},(function(){var _=this,a=_._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"简单的完成面试结构知识复习"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单的完成面试结构知识复习"}},[_._v("#")]),_._v(" 简单的完成面试结构知识复习")]),_._v(" "),a("blockquote",[a("p",[_._v("知识就像火焰，燃起火焰的人越多，火才能烧的更旺。")])]),_._v(" "),a("h2",{attrs:{id:"_1-java基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-java基础"}},[_._v("#")]),_._v(" 1.Java基础")]),_._v(" "),a("h3",{attrs:{id:"_1-java基本数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-java基本数据类型"}},[_._v("#")]),_._v(" 1. Java基本数据类型")]),_._v(" "),a("blockquote",[a("p",[_._v("char 、 int 、 short、 long、 float、 double、 boolean、byte")])]),_._v(" "),a("h3",{attrs:{id:"_2-泛型、封装、多态、继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-泛型、封装、多态、继承"}},[_._v("#")]),_._v(" 2. 泛型、封装、多态、继承")]),_._v(" "),a("ul",[a("li",[_._v("泛型")])]),_._v(" "),a("blockquote",[a("p",[_._v("泛型，有类泛型、方法泛型、本质是其实是一种Java语法糖，对于Java虚拟机来讲它是不认识泛型的，在编译的时候会进行解语法糖进行类型的擦除。\n我觉得泛型带来最大的好处是增加代码的可读性和数据类型的校验，有泛型的存在可以让代码更清晰，同时减少因为没有限制数据类型而产生的一些类型转换操作亦或者报错。")])]),_._v(" "),a("ul",[a("li",[_._v("封装")])]),_._v(" "),a("blockquote",[a("p",[_._v("通过面向对象的设计思维，抽象出对象的类型、属性和方法封装成为一个整体，对外只暴露一些功能方法接口，隐藏具体的属性和方法实现细节")])]),_._v(" "),a("ul",[a("li",[_._v("多态")])]),_._v(" "),a("blockquote",[a("p",[_._v("分运行时多态和编译时多态，通常我们说的时运行时多态，表现形式为方法的重写，实现机制是通过继承来实现。\n编译时多态说的是方法的重载，是静态的。\n运行时多态说的是方法的重写，在编译期间重写的方法的指向还是不确定的，只有等到真正运行的到的时候我们才知道指向的方法，也就是我们说的多态性")])]),_._v(" "),a("ul",[a("li",[_._v("继承")])]),_._v(" "),a("blockquote",[a("p",[_._v("继承是保持已有类的特性构造新类的过程，Java提供了成熟的继承机制，只需要使用指定的关键字extends即可")])]),_._v(" "),a("h3",{attrs:{id:"_3-访问权限修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-访问权限修饰符"}},[_._v("#")]),_._v(" 3. 访问权限修饰符")]),_._v(" "),a("ul",[a("li",[_._v("public")])]),_._v(" "),a("blockquote",[a("p",[_._v("公有的，表示公开访问权限，项目类路径下，任何类可以进行访问")])]),_._v(" "),a("ul",[a("li",[_._v("private")])]),_._v(" "),a("blockquote",[a("p",[_._v("私有的表示类私有，只有类本身可以访问")])]),_._v(" "),a("ul",[a("li",[_._v("protected")])]),_._v(" "),a("blockquote",[a("p",[_._v("受保护的，主要用来保护子类的访问权限，通常情况没有意义，同一个包下可以进行访问。在继承关系中，父类可以访问子类继承的受保护权限的属性和方法，\n即时不再同一个包下，通过继承关系，子类可以访问父类受保护权限的属性和方法，并且子类继承了受保护权限的属性和方法之后，可以让其在子类的包下可访问")])]),_._v(" "),a("ul",[a("li",[_._v("default")])]),_._v(" "),a("blockquote",[a("p",[_._v("默认的，同一包下可访问，声明的时候没有加修饰符，默认是友好的")])]),_._v(" "),a("h3",{attrs:{id:"_4-异常"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-异常"}},[_._v("#")]),_._v(" 4. 异常")]),_._v(" "),a("blockquote",[a("p",[_._v("从主体结构来讲，异常分为：错误、一般异常、运行时异常")])]),_._v(" "),a("ul",[a("li",[_._v("错误")])]),_._v(" "),a("blockquote",[a("p",[_._v("如果出现错误那么程序将无法恢复，常见的错误一般都是虚拟机的错误，比如内存溢出、堆栈溢出等错误")])]),_._v(" "),a("ul",[a("li",[_._v("一般异常")])]),_._v(" "),a("blockquote",[a("p",[_._v("一般异常也指受检(受控)异常，出现这种异常都需要显式的进行处理，不然程序无法编译通过")])]),_._v(" "),a("ul",[a("li",[_._v("运行时异常")])]),_._v(" "),a("blockquote",[a("p",[_._v("运行时异常也指非受检（受控）异常，出现这种异常可以不进行显式的处理，例如被零除异常、空指针异常等\n通常时程序员设计编程时考虑不周导致。\n一般的运行时异常有：")])]),_._v(" "),a("ol",[a("li",[_._v("空指针异常")]),_._v(" "),a("li",[_._v("被零除异常")]),_._v(" "),a("li",[_._v("数组索引越界")]),_._v(" "),a("li",[_._v("方法找不到")]),_._v(" "),a("li",[_._v("类定义错误")]),_._v(" "),a("li",[_._v("类名找不到")]),_._v(" "),a("li",[_._v("数据类型转换异常")]),_._v(" "),a("li",[_._v("sql异常")]),_._v(" "),a("li",[_._v("实例化异常")]),_._v(" "),a("li",[_._v("字符串转换数字类型异常")])]),_._v(" "),a("h3",{attrs:{id:"_5-aio、nio、bio的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-aio、nio、bio的区别"}},[_._v("#")]),_._v(" 5. AIO、NIO、BIO的区别")]),_._v(" "),a("p",[_._v("Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。")]),_._v(" "),a("ol",[a("li",[_._v("BIO，同步阻塞")]),_._v(" "),a("li",[_._v("NIO，同步非阻塞")]),_._v(" "),a("li",[_._v("AIO，异步非阻塞")])]),_._v(" "),a("h3",{attrs:{id:"_6-其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-其他"}},[_._v("#")]),_._v(" 6. 其他")]),_._v(" "),a("ol",[a("li",[_._v("抽象方法不能是静态的")]),_._v(" "),a("li",[_._v("静态方法里面不能直接调用一个非静态方法，因为非静态方法属于类的对象，只有初始化之后才存在，直接调用可能会调用一个未初始化的对象所以无法编译通过")]),_._v(" "),a("li",[_._v("反射主要用到的几个类分别是Class、Method、Constructor、Field")])]),_._v(" "),a("h2",{attrs:{id:"_2-数据结构和算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据结构和算法"}},[_._v("#")]),_._v(" 2.数据结构和算法")]),_._v(" "),a("p",[_._v("这两个其实挺重要的，即时时不进行面试，日常工作中应该都能接触到，面试主要问的其实也就那几个")]),_._v(" "),a("h3",{attrs:{id:"_1-数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据结构"}},[_._v("#")]),_._v(" 1.数据结构")]),_._v(" "),a("p",[_._v("这里主要讲list集合和map")]),_._v(" "),a("h4",{attrs:{id:"_1-list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-list"}},[_._v("#")]),_._v(" 1.list")]),_._v(" "),a("ul",[a("li",[_._v("arrayList")])]),_._v(" "),a("blockquote",[a("p",[_._v("底层数据结构是可变数组，线程不安全，无参构建默认容量是0，如果是无参第一次扩容是10，之后是按1.5倍进行扩容")])]),_._v(" "),a("ul",[a("li",[_._v("vector")])]),_._v(" "),a("blockquote",[a("p",[_._v("底层数据结构同样是可变数组，线程安全，无参默认容量是10，满后按2倍扩容")])]),_._v(" "),a("ul",[a("li",[_._v("linkList")])]),_._v(" "),a("blockquote",[a("p",[_._v("底层数据结构是双向链表，相比于arrayList，增删效率较高，改查效率较低")])]),_._v(" "),a("h4",{attrs:{id:"_2-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-map"}},[_._v("#")]),_._v(" 2.map")]),_._v(" "),a("ul",[a("li",[_._v("hashMap\n"),a("ul",[a("li",[_._v("jdk1.7之前数据结构是数组 + 链表，主体是数组，链表是为了解决哈希冲突，链表是单链表，")]),_._v(" "),a("li",[_._v("jdk1.8之后引入红黑树结构，用来解决哈希冲突之后链表过长，查询效率变低的问题")]),_._v(" "),a("li",[_._v("默认负载因子是0.75，默认map长度是16，扩容阈值是 负载因子乘与map长度，默认是0.75*16 = 12")]),_._v(" "),a("li",[_._v("当链表长度大于8，实际数组总量大于64，链表才会变成红黑树，如果没达到这个要求，会触发扩容机制，如果达到要求转化成红黑树之后，数据减少红黑树也会重新转化成链表")]),_._v(" "),a("li",[_._v("之所以转化红黑树还需要这么多的条件，主要是链表长度小的时候其实查询效率还是可以的，之后链表长度大于8，实际数据总量大于64，查询效率才会不理想")]),_._v(" "),a("li",[_._v("map的扩容机制也是默认按两倍进行扩容，扩容后如果是未指定map初始容量一般是16变成32，相当于一个比bit位的运算，\n如果是一个bit位，原map中数据索引的值变为 本身 + 扩容长度，如果没有达到一位，则索引值不变")]),_._v(" "),a("li",[_._v("hashMap线程不安全")]),_._v(" "),a("li",[_._v("解决哈希冲突的方法有再哈希法、开放地址法和链地址法等方法，hashMap使用的是链地址法，解决哈希冲入计算，开发地址法是，如果p=H(key)出现冲突时，则以p为基础，再次hash。\n再哈希法是：提供多个不同的hash函数，R1=H1(key1)发生冲突时，再计算R2=H2（key1）")])])]),_._v(" "),a("li",[_._v("hashTable\n"),a("ul",[a("li",[_._v("同样和hashMap，都是基于哈希表实现，同样是数组 + 链表的数据结构，都实现了序列化接口Serializable支持序列化")]),_._v(" "),a("li",[_._v("hashTable是线程安全的")])])]),_._v(" "),a("li",[_._v("hashMap和hashTable的区别\n"),a("ul",[a("li",[_._v("hashMap线程不安全，hashTable是线程安全的")]),_._v(" "),a("li",[_._v("hashMap的key和value都可以是null,hashTable不行，非常会报空指针错误")]),_._v(" "),a("li",[_._v("hashMap默认是两倍进行扩容，hashTable是两倍 + 1")]),_._v(" "),a("li",[_._v("计算哈希值的方式不一样")]),_._v(" "),a("li",[_._v("继承的父类不一样，hashMap是继承AbstractMap，hashTable是继承Dictionary")])])]),_._v(" "),a("li",[_._v("concurrentHashMap（线程安全）\n"),a("ul",[a("li",[_._v("jdk1.7 中的concurrentHashMap是有segment数组和HashEntry数组结构组成，相当于把hashMap的桶拆分成多个小数组segment,每个segment由多个hashEntry组成。")]),_._v(" "),a("li",[_._v("jdk1.7 中的concurrentHashMap通过给segment数组加锁的设定，在线程占用锁访问其中一段数据时，其他数据不受影响，做到了真正的并发访问。也就是segment分段锁")]),_._v(" "),a("li",[_._v("jdk1.8 之后的concurrentHashMap和HashMap一样采用了数组 + 链表 + 红黑树的结构，抛弃了原有的segment分段锁，采用CAS + synchronized实现了更细粒度的锁")]),_._v(" "),a("li",[_._v("jdk1.8 之后的concurrentHashMap将锁的级别控制在更细粒度的哈希桶数组元素级别，也就是说只需要锁住这个桶就不会影响其他的桶元素读写大大提高了并发")]),_._v(" "),a("li",[_._v("concurrentHashMap的key和value不能为null，会影响数据判断")]),_._v(" "),a("li",[_._v("相较于同样线程安全的hashTable,ConcurrentHashMap 的效率要高于 Hashtable，因为Hashtable的锁是锁全表，ConcurrentHashMap是更细粒度的锁，可以提高并发支持")])])])]),_._v(" "),a("h3",{attrs:{id:"_2-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-算法"}},[_._v("#")]),_._v(" 2.算法")]),_._v(" "),a("p",[_._v("一到两年一般只问一下那个排序算法")]),_._v(" "),a("h4",{attrs:{id:"_1-快速排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-快速排序"}},[_._v("#")]),_._v(" 1.快速排序")]),_._v(" "),a("blockquote",[a("p",[_._v("定义排序集合其中一个数为基准数，然后总两边开始找，每次都是右边先走因为设置的基准数时左边的第一个，左边找大于基准数的数，右边找小于基准数的数，找到就停下换另一个找，都找到之后，交换找到的数，直到相遇，\n当左右两边相遇时，将相遇位置的数和基准数互换，互换之后如果基准数左边的只剩下一个数，说明左边已经完成查找，继续按照相同逻辑找右边，如果没有就定义基准数左边的第一个数为基准数，继续按照相同逻辑完成左边的查找再找右边，实现思路主要是二分查找和递归。")])]),_._v(" "),a("p",[_._v("参考链接："),a("a",{attrs:{href:"https://blog.csdn.net/qq_40941722/article/details/94396010?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166158652016782246449282%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166158652016782246449282&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-94396010-null-null.142%5Ev42%5Enew_blog_pos_by_title,185%5Ev2%5Etag_show&utm_term=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187",target:"_blank",rel:"noopener noreferrer"}},[_._v("快速排序法（详解）"),a("OutboundLink")],1)]),_._v(" "),a("h4",{attrs:{id:"_2-冒泡排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-冒泡排序"}},[_._v("#")]),_._v(" 2.冒泡排序")]),_._v(" "),a("blockquote",[a("p",[_._v("需要对排序集合进行n-1轮排序，n为集合大小，每轮比较从第一位开始和后面的数进行比较，将大的数替换到下一个，依次类推将最大的数放在集合最后一位，每轮比较需要比较的数会减少一个，因为最后一个已经确定了是上一轮的最大值。")])]),_._v(" "),a("h4",{attrs:{id:"_3-二分法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-二分法"}},[_._v("#")]),_._v(" 3.二分法")]),_._v(" "),a("blockquote",[a("p",[_._v("通指定一个中间值将排序集合分为两个数组，左边放小于中间值的数，右边放大于中间值的数，然后对两边数组做重复操作直至数组只剩下一个元素，将数组合并起来，实际实现也是二分加递归完成排序。\n其实和快速排序基本差不多。")])]),_._v(" "),a("h2",{attrs:{id:"_3-java并发、多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-java并发、多线程"}},[_._v("#")]),_._v(" 3.Java并发、多线程")]),_._v(" "),a("p",[_._v("这块主要记一些一些常考面试题，暂时不进行具体知识点分析")]),_._v(" "),a("h3",{attrs:{id:"_1-sleep和wait的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-sleep和wait的区别"}},[_._v("#")]),_._v(" 1.sleep和wait的区别")]),_._v(" "),a("ol",[a("li",[_._v("sleep 方法只让出了CPU，而并不会释放同步资源锁，休眠完之后，自动醒来")]),_._v(" "),a("li",[_._v("wait 释放同步资源锁，休眠完之后需要主动调用notify()方法，或者notifyAll()")]),_._v(" "),a("li",[_._v("sleep 方法可以在任何地方使用，wait方法只能在同步方法亦或者同步块中使用")])]),_._v(" "),a("h3",{attrs:{id:"_2-runnable接口和callable接口区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-runnable接口和callable接口区别"}},[_._v("#")]),_._v(" 2.Runnable接口和Callable接口区别")]),_._v(" "),a("ol",[a("li",[_._v("runnable没有返回值，callable有返回值")]),_._v(" "),a("li",[_._v("runnable的异常只能在内部处理无法向上抛出，callable可以在内部处理也可以向上抛出在外面处理")])]),_._v(" "),a("h3",{attrs:{id:"_3-synchronized-和-lock的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-synchronized-和-lock的区别"}},[_._v("#")]),_._v(" 3. synchronized 和 Lock的区别")]),_._v(" "),a("ol",[a("li",[_._v("Lock 能完成基本 synchronized 所有的功能，还有synchronized没有的功能，比如锁投票 、定时锁等候等")]),_._v(" "),a("li",[_._v("Lock锁需要手动释放，synchronized由jvm自动释放")])]),_._v(" "),a("h2",{attrs:{id:"_4-java、jdk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-java、jdk"}},[_._v("#")]),_._v(" 4.Java、jdk")]),_._v(" "),a("h3",{attrs:{id:"_1-jdk1-8新特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-jdk1-8新特性"}},[_._v("#")]),_._v(" 1. jdk1.8新特性")]),_._v(" "),a("ol",[a("li",[_._v("函数式接口：")]),_._v(" "),a("li",[_._v("lambda表达式")]),_._v(" "),a("li",[_._v("stream api")]),_._v(" "),a("li",[_._v("方法引用/构造函数引用")]),_._v(" "),a("li",[_._v("新时间日期,localtime")]),_._v(" "),a("li",[_._v("optional容器类")]),_._v(" "),a("li",[_._v("接口新增default方法 static方法，接口允许有一些默认实现。static方法需要通过接口名直接调用，default方法可通过实现接口的实例对象调用亦或者重写。")]),_._v(" "),a("li",[_._v("hashMap引入红黑树结构")])]),_._v(" "),a("h3",{attrs:{id:"_2-jvm-类加载机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-jvm-类加载机制"}},[_._v("#")]),_._v(" 2. jvm 类加载机制")]),_._v(" "),a("p",[_._v("当程序主动使用某个类的时候，如果该类未被加载，jvm会对该类进行初始化，也就是类加载，jvm通过三个步骤完成类加载分别是： 加载、链接 、初始化，其中链接也可以分为三个部分：\n验证、准备、解析。当然类加载器通常无须等到“首次使用”该类时才加载该类，jvm预先加载某些类。")]),_._v(" "),a("blockquote",[a("p",[_._v("类加载时机有，创建类的实例，初始化子类会先加载其父类、访问类的静态变量亦或者静态方法、反射、jvm启动时标志的启动类")])]),_._v(" "),a("ol",[a("li",[_._v("加载\n将编译好的class文件，加载到内存")]),_._v(" "),a("li",[_._v("链接\n"),a("ul",[a("li",[_._v("验证"),a("br"),_._v("\n检查加载的类是否有正确的内部结构，比如class文件开头的魔数是否正确，开头是否是 cafebabe，")]),_._v(" "),a("li",[_._v("准备"),a("br"),_._v("\n准备阶段会给类的静态变量分配内存，并将其初始化为默认值")]),_._v(" "),a("li",[_._v("解析"),a("br"),_._v("\n把类中的符号引用转换为直接引用")])])]),_._v(" "),a("li",[_._v("初始化\n初始化阶段是给类的静态变量赋予定义的正确初始值")])]),_._v(" "),a("h3",{attrs:{id:"_3-jvm-运行时内存结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-jvm-运行时内存结构"}},[_._v("#")]),_._v(" 3. jvm 运行时内存结构")]),_._v(" "),a("p",[_._v("jvm运行时内存结构主要分为五个部分，分别是：程序计数器、虚拟机栈、本地方法栈、堆内存、方法区")]),_._v(" "),a("p",[_._v("线程私有：程序计数器、虚拟机栈、本地方法栈\n线程共享：堆内存、方法区 、堆外内存（Java7的永久代或JDK8的元空间、代码缓存）")]),_._v(" "),a("ol",[a("li",[_._v("程序计数器"),a("br"),_._v("\n程序计数器是一块较小的内存空间，可以看作是当前线程执所执行字节码所行的行号指示器。当cpu在多个线程中切换时，程序计数器会将下一行将执行字节码的行号记录下来，\n当cpu切换回来的时候，可以从记录位置开始恢复线程的执行")]),_._v(" "),a("li",[_._v("虚拟机栈"),a("br"),_._v("\n虚拟机栈，其实说的是Java方法执行时的内存模型，内部主要结构类似于一个栈帧管道，执行先入后出的原则，当线程执行到某一个方法是会创建一个栈帧，压入虚拟机栈。\n每个栈帧内部结构区分为：局部变量表、操作数栈、动态链接、返回地址、附加信息\n"),a("ul",[a("li",[_._v("局部变量表"),a("br"),_._v("\n主要作用是存储方法参数和定义在方法体内的局部变量，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。")]),_._v(" "),a("li",[_._v("操作数栈"),a("br"),_._v("\n主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新 PC 寄存器中下一条需要执行的字节码指令\n另外我们说Java虚拟机栈的解释引擎是基于栈的执行引擎，这里的栈指的就是操作数栈")]),_._v(" "),a("li",[_._v("动态链接"),a("br"),_._v("\n将符号引用转换为调用方法的直接引用")]),_._v(" "),a("li",[_._v("返回地址"),a("br"),_._v("\n用来存放调用该方法的 PC 寄存器的值。也就是记录执行到具体方法的那一步")]),_._v(" "),a("li",[_._v("附加信息"),a("br"),_._v("\n栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。")])])]),_._v(" "),a("li",[_._v("本地方法栈"),a("br"),_._v("\n虚拟机栈用来管理Java方法的调用，本地方法栈用来管理本地方法的调用，类似于虚拟机栈。本地方法并不是使用Java语言实现的，一般是c语言。")]),_._v(" "),a("li",[_._v("堆内存"),a("br"),_._v("\n堆内存是Java虚拟机管理内存中最大的一块，主要用来存放对象实例，被所有线程共享，在逻辑上被划分为三块区域，新生代、老年代、永久代（jdk1.8之后叫元空间）\n"),a("ul",[a("li",[a("p",[_._v("新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代")]),_._v(" "),a("ul",[a("li",[_._v("新生代又被划分为两个幸存者区域和一个伊甸区，空间大小分别是1：1：8")]),_._v(" "),a("li",[_._v("新创建的实例对象都存档在伊甸区，每次伊甸区填充对象会进行一个小GC将存活对象放大其中一个幸存者区")]),_._v(" "),a("li",[_._v("幸存者区同时只有一个区域存在对象，每次小GC都会将幸存者区域存储空间变换成另一个将之前存放对象的空间空出来")]),_._v(" "),a("li",[_._v("经过多次 GC 循环后存活下来的对象被移动到老年代，一般这个次数好像是15次")]),_._v(" "),a("li",[_._v("注意如果创建的对象需要很大的连续内存空间，会直接放入老年代，避免在伊甸区和幸存者区进行大量的内存拷贝")])])]),_._v(" "),a("li",[a("p",[_._v("老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大")]),_._v(" "),a("ul",[a("li",[_._v("主要存放经过多轮小型GC依旧存活的对象")]),_._v(" "),a("li",[_._v("老年代满了之后会进行垃圾收集，也就是主GC，通常需要更长时间")]),_._v(" "),a("li",[_._v("判断一个对象是否可回收方法大致有如下：\n"),a("ul",[a("li",[_._v("引用计数法")]),_._v(" "),a("li",[_._v("可达性分析")])])]),_._v(" "),a("li",[_._v("垃圾收集的方法大致有如下：\n"),a("ul",[a("li",[_._v("标记，清除，标记存活对象，然后清理其他未被标记的内存，这种方式容易产生大量的内存碎片")]),_._v(" "),a("li",[_._v("标记，整理，标记存活对象，让所有存活对象往一个方向移动，然后清理对象边界以外的内存")]),_._v(" "),a("li",[_._v("复制，将内存分为两块，只使用其中一块，将存活对象复制到另一块，清理之前使用的内存块")])])])])]),_._v(" "),a("li",[a("p",[_._v("堆内存使用的垃圾回收算法是：分代收集算法。将堆内存分为新生代、老年代")]),_._v(" "),a("ul",[a("li",[_._v("新生代：使用复制算法")]),_._v(" "),a("li",[_._v("老年代：使用标记清除亦或者标记整理算法")])])]),_._v(" "),a("li",[a("p",[_._v("元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存，其实这一块就是我们接下来要将的方法区，因为这一块内存还有一个别名Non-Heap（非堆），\n其目的应该就是要与堆内存分离开来，所以这一块在下面进行解释")])])])]),_._v(" "),a("li",[_._v("方法区"),a("br"),_._v("\n方法区与堆一样是线程共享的，它还有一个别名Non-Heap(非堆)，Java虚拟机规范把方法区描述为堆的一个逻辑部分。运行时常量池也是方法区的一部分，jvm关闭的时候方法区即释放。\n方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。")])]),_._v(" "),a("ul",[a("li",[_._v("方法区，只是jvm规范中定义的一个概念，用来存储，类信息、常量池、静态变量、jit编译后的代码等数据")]),_._v(" "),a("li",[_._v("方法区的内部结构：类型信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据")])]),_._v(" "),a("h3",{attrs:{id:"_4-jmm-java内存模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-jmm-java内存模型"}},[_._v("#")]),_._v(" 4. JMM (Java内存模型)")]),_._v(" "),a("p",[_._v("主要控制的是线程之间的通信，具体的信息这里不做详解")]),_._v(" "),a("h3",{attrs:{id:"_5-内存泄漏和内存溢出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-内存泄漏和内存溢出"}},[_._v("#")]),_._v(" 5. 内存泄漏和内存溢出")]),_._v(" "),a("h4",{attrs:{id:"_1-内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存泄漏"}},[_._v("#")]),_._v(" 1. 内存泄漏")]),_._v(" "),a("blockquote",[a("p",[_._v("内存泄漏是指程序在申请内存后，无法释放已申请的内存空间，一次泄漏似乎不会有太大的问题，但内存泄漏堆积后的后果就是会造成内存溢出")])]),_._v(" "),a("p",[_._v("内存泄漏分类：")]),_._v(" "),a("ol",[a("li",[_._v("常发性内存泄漏，发生内存泄漏的代码被多次执行，每次执行都会导致一块内存泄漏")]),_._v(" "),a("li",[_._v("偶发性内存泄漏，发型内存泄漏的代码只有在某些特定环境亦或者特殊操作才会被执行，常发性和偶发性是相对的。")]),_._v(" "),a("li",[_._v("一次性内存泄漏，发生内存泄漏的代码只会被执行一次。或者由于算法上的缺陷，总会导致有且只有一块内存发生泄漏")]),_._v(" "),a("li",[_._v("隐式内存泄漏，程序在运行过程中不断的分配内存，但直到程序结束的时候才释放内存。严格来讲这里不算是内存泄漏，因为这些内存最终都会进行释放，\n但是由于服务器运行持续的时间一般都会很长，所以不及时释放内存也可能导致最终系统耗尽所有内存，这种情况称为隐式内存泄漏")])]),_._v(" "),a("p",[_._v("内存泄漏解决方案：")]),_._v(" "),a("ol",[a("li",[_._v("查看运行日志，是否存在异常亦或者错误")]),_._v(" "),a("li",[_._v("检查代码逻辑走向分析可能没有关闭的流亦或者没有释放的对象")])]),_._v(" "),a("h4",{attrs:{id:"_2-内存溢出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-内存溢出"}},[_._v("#")]),_._v(" 2. 内存溢出：")]),_._v(" "),a("blockquote",[a("p",[_._v("内存溢出指程序在申请内存的时候没有足够的内存供申请者使用。")])]),_._v(" "),a("p",[_._v("内存溢出原因：")]),_._v(" "),a("ol",[a("li",[_._v("内存中加载的数据过于庞大，比如一次性从数据库中取出过多的数据。")]),_._v(" "),a("li",[_._v("集合中有对对象的引用使用后未清空，jvm无法回收")]),_._v(" "),a("li",[_._v("代码中存在死循环，亦或者循环产生过多的重复对象")]),_._v(" "),a("li",[_._v("使用第三方软件的bug")]),_._v(" "),a("li",[_._v("jvm启动参数的内存设置过小")])]),_._v(" "),a("p",[_._v("解决方案：")]),_._v(" "),a("ol",[a("li",[_._v("修改jvm启动参数增加内存")]),_._v(" "),a("li",[_._v("查看错误日志内存溢出前是否存在其他的异常或者错误")]),_._v(" "),a("li",[_._v("对代码逻辑走向分析，找出可能出现内存溢出的位置进行核对")])]),_._v(" "),a("h4",{attrs:{id:"_3-两者的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-两者的关系"}},[_._v("#")]),_._v(" 3. 两者的关系")]),_._v(" "),a("ol",[a("li",[_._v("内存泄漏最终会导致内存溢出")]),_._v(" "),a("li",[_._v("内存溢出其实也可以理解为，程序需要的内存空间，系统没办法满足。")])]),_._v(" "),a("h2",{attrs:{id:"_5-设计模式和架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-设计模式和架构"}},[_._v("#")]),_._v(" 5. 设计模式和架构")]),_._v(" "),a("p",[_._v("这块知识点较多，此处只做简单记录，分为面向对象七个设计原则、23种设计模式和一种简单工厂模式、其他的架构知识可能只是简单提一下")]),_._v(" "),a("h3",{attrs:{id:"_1-七个设计原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-七个设计原则"}},[_._v("#")]),_._v(" 1. 七个设计原则")]),_._v(" "),a("ol",[a("li",[_._v("单一职责原则")]),_._v(" "),a("li",[_._v("依赖倒置原则")]),_._v(" "),a("li",[_._v("迪米特法则")]),_._v(" "),a("li",[_._v("开闭原则")]),_._v(" "),a("li",[_._v("接口隔离原则")]),_._v(" "),a("li",[_._v("里氏替换原则")]),_._v(" "),a("li",[_._v("组合/复用原则")])]),_._v(" "),a("h3",{attrs:{id:"_2-23种设计模式-简单工厂设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-23种设计模式-简单工厂设计模式"}},[_._v("#")]),_._v(" 2. 23种设计模式 + 简单工厂设计模式")]),_._v(" "),a("p",[_._v("23种设计模式主要分为三大类，分辨解决对应问题，分为：创建型设计模式，解决对象创建问题、结构型设计模式，解决类结构问题也就是类和对象之间的组合或组装问题、行为型设计模式，解决类行为问题也就是类和对象之间的交互问题")]),_._v(" "),a("ul",[a("li",[_._v("创建型")])]),_._v(" "),a("ol",[a("li",[_._v("工厂方法设计模式\n"),a("ul",[a("li",[_._v("定义一个抽象的产品工厂，由具体工厂生成具体的产品")])])]),_._v(" "),a("li",[_._v("抽象工厂设计模式\n"),a("ul",[a("li",[_._v("定义一个产品族工厂，由具体工厂生成具体的产品族")])])]),_._v(" "),a("li",[_._v("单例模式\n"),a("ul",[a("li",[_._v("只实例化一个对象，并向提供全局访问，有好几种实现方式，比如懒汉、饿汉式，枚举也是一种单例模式")])])]),_._v(" "),a("li",[_._v("原型模式\n"),a("ul",[a("li",[_._v("基于对象克隆和拷贝，区分浅拷贝和深拷贝，浅拷贝实现父类object对象的clone方法，深拷贝可以通过序列化成输出字节流，然后再转化成输入流完成深拷贝")])])]),_._v(" "),a("li",[_._v("建造者模式\n"),a("ul",[a("li",[_._v("复杂对象，并且属性间存在一定的依赖顺序，才会使用的设计模式，通常比较少用")])])])]),_._v(" "),a("ul",[a("li",[_._v("结构型")])]),_._v(" "),a("ol",[a("li",[_._v("适配器模式\n"),a("ul",[a("li",[_._v("将一个接口转换成客户希望的另一个接口，是不兼容的类可以一起工作")])])]),_._v(" "),a("li",[_._v("外观模式\n"),a("ul",[a("li",[_._v("为系统中的一组接口，提供一个统一的接口。")])])]),_._v(" "),a("li",[_._v("组合模式\n"),a("ul",[a("li",[_._v("组合对各对象形成属性结构，以表示具体“整体-部分”关系的层次结构")])])]),_._v(" "),a("li",[_._v("享元模式")]),_._v(" "),a("li",[_._v("代理模式")]),_._v(" "),a("li",[_._v("桥接模式")]),_._v(" "),a("li",[_._v("装饰模式")])]),_._v(" "),a("ul",[a("li",[_._v("行为型")])]),_._v(" "),a("ol",[a("li",[_._v("迭代器模式\n"),a("ul",[a("li",[_._v("提供一种方法来访问聚合对象，而不用暴露这个对象的内部不表示")])])]),_._v(" "),a("li",[_._v("观察者模式\n"),a("ul",[a("li",[_._v("定义对象之间的一种一对多的依赖关系使得每当一个对象状态发生改变时，其相关依赖对象都得到通知，并被自动更新")])])]),_._v(" "),a("li",[_._v("策略模式\n"),a("ul",[a("li",[_._v("定义一系列算法，将每一个算法封装起来，并让他们可以相互替换，策略模式让算法独立于他的客户而变化，也称为政策模式。")])])]),_._v(" "),a("li",[_._v("模板方法模式")]),_._v(" "),a("li",[_._v("职责链模式")]),_._v(" "),a("li",[_._v("状态模式")]),_._v(" "),a("li",[_._v("中介模式")]),_._v(" "),a("li",[_._v("备忘录模式")]),_._v(" "),a("li",[_._v("解释器模式")]),_._v(" "),a("li",[_._v("命令模式")]),_._v(" "),a("li",[_._v("访问者模式")])]),_._v(" "),a("h3",{attrs:{id:"_3-ddd-领域驱动架构设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-ddd-领域驱动架构设计"}},[_._v("#")]),_._v(" 3. ddd 领域驱动架构设计")]),_._v(" "),a("p",[_._v("ddd 领域驱动设计是一种软件核心复杂业务应对之道，但它并不是唯一的解决方案，也并不是所有的业务都适合DDD架构，相对于系统初期业务逻辑相对简单的应用，\n传统的MVC架构更具优势，也可以减少一些认知成本和开发成本。")]),_._v(" "),a("ul",[a("li",[_._v("优点\nDDD最大的好处是，扭转传统的设计思想，接触到业务的第一时间，不是将业务分析成数据和行为，而是针对业务进行抽象，面向对象编程，而不是过程式的业务逻辑实现。")])]),_._v(" "),a("p",[_._v("通过扭转设计思想,DDD可以将复杂的业务领域简单化，实现代码即设计等优点，解决应对业务较为复杂、应用架构不清晰、越来越臃肿等问题。")]),_._v(" "),a("ul",[a("li",[_._v("难点\n主要还是DDD的编程思维和传统业务实现思维解决问题的角度是不一致的，转变过来可能需要较多的理解成本")])]),_._v(" "),a("h3",{attrs:{id:"_4-怎样的代码结构才是好的代码结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-怎样的代码结构才是好的代码结构"}},[_._v("#")]),_._v(" 4. 怎样的代码结构才是好的代码结构？")]),_._v(" "),a("h2",{attrs:{id:"_6-框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-框架"}},[_._v("#")]),_._v(" 6. 框架")]),_._v(" "),a("h3",{attrs:{id:"_1-spring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-spring"}},[_._v("#")]),_._v(" 1. spring")]),_._v(" "),a("p",[_._v("spring框架的核心思想其实就是简化开发，最初的设计目的应该是：让JAVA EE开发更加容易。")]),_._v(" "),a("ul",[a("li",[_._v("特性")])]),_._v(" "),a("ol",[a("li",[_._v("非侵入式，基于spring开发的对象，可以不依赖于spring的API")]),_._v(" "),a("li",[_._v("控制反转，IOC")]),_._v(" "),a("li",[_._v("依赖注入，DI")]),_._v(" "),a("li",[_._v("组件化，spring实现了使用简单的组件配置，组合成一个复杂的应用")]),_._v(" "),a("li",[_._v("容器，还是一个容器，它包含并且管理对象的生命周期")]),_._v(" "),a("li",[_._v("一站式，在IOC和AOP的基础上整合各种企业应用的开源框架和优秀类库，并且spring自身也提供了表现层的springMvC，持久层的spring JDBC")])]),_._v(" "),a("h4",{attrs:{id:"_1-spring-mvc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-spring-mvc"}},[_._v("#")]),_._v(" 1. spring MVC")]),_._v(" "),a("h5",{attrs:{id:"mvc-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvc-是什么"}},[_._v("#")]),_._v(" MVC 是什么")]),_._v(" "),a("p",[_._v("MVC 的英文是 model（模型） view（视图） controller（控制器），是一种软件设计规范，本质上是项目开发内容的解耦")]),_._v(" "),a("ul",[a("li",[_._v("Model（模型）"),a("br"),_._v("\n是应用程序中用来处理数据逻辑的部分")]),_._v(" "),a("li",[_._v("View（视图）"),a("br"),_._v("\n是应用程序中处理数据现实的部分")]),_._v(" "),a("li",[_._v("Controller（控制器）\n是应用程序中处理用户交互的部分")])]),_._v(" "),a("h5",{attrs:{id:"spring-mvc是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc是什么"}},[_._v("#")]),_._v(" spring MVC是什么")]),_._v(" "),a("p",[_._v("springMVC是spring基于spring core 、AOP、 IOC等核心技术的基础上，遵循web MVC 开发规范， 推出的web 开发框架，目的主要还是简化web 开发")]),_._v(" "),a("ul",[a("li",[_._v("特性")])]),_._v(" "),a("ol",[a("li",[_._v("进行更简洁的web层开发")]),_._v(" "),a("li",[_._v("天生于spring框架集成")]),_._v(" "),a("li",[_._v("提供强大的约定大于配置的契约式编程支持")]),_._v(" "),a("li",[_._v("支持灵活的url到页面控制器的映射")]),_._v(" "),a("li",[_._v("提供一套强大的jsp标签库，简化jsp开发")]),_._v(" "),a("li",[_._v("支持restful 风格，系统上的一切对象都要抽象为资源，每个资源对应一个唯一表示（URL），所有的操作都是无状态的等等")])]),_._v(" "),a("h4",{attrs:{id:"_2-spring-ioc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-spring-ioc"}},[_._v("#")]),_._v(" 2. spring IOC")]),_._v(" "),a("p",[_._v("控制反转，其实说的是我们创建对象的过程中对“对象”控制权的一个转变，是一种编程的设计思想，怎么理解呢？\n传统的创建对象方式，我们需要主动去new一个对象并需要自己直接获取依赖对象，而spring框架中创建一个我们需要的bean对象，\n我们不再需要主动去new只需要被动接受spring框架帮我们创建，并且通过依赖注入的方式把依赖对象注入创建好对象返回给我们，这个改变的过程其实就是我们说的控制反转。")]),_._v(" "),a("h4",{attrs:{id:"_3-spring-aop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-spring-aop"}},[_._v("#")]),_._v(" 3. spring AOP")]),_._v(" "),a("p",[_._v("AOP的含义是面向切面编程，AOP最早是AOP联盟的组织提出的,指定的一套规范,spring将AOP思想引入框架中，通过预编译方式和运行期间动态代理实现程序统一维护的一种技术")]),_._v(" "),a("h4",{attrs:{id:"_4-bean的创建流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-bean的创建流程"}},[_._v("#")]),_._v(" 4. bean的创建流程")]),_._v(" "),a("ol",[a("li",[_._v("启动spring容器，创建bean工厂之后，一般会由bean工厂的子类applicationcontext去加载配置文件，获取bean的配置信息")]),_._v(" "),a("li",[_._v("拿到bean的配置信息之后会通过  BeanDefinitionReader这个接口，解析配置得到对应的BeanDefinition对象")]),_._v(" "),a("li",[_._v("spring会将这些BeanDefinition对象放入到一个Map里面，key就使用对应的bean名称，传入到bean工厂")]),_._v(" "),a("li",[_._v("bean工厂会使用一些处理器对BeanDefinition的属性做一些修改，修改完了之后才会进行实例化，也就是通过反射的方式获取到对应的类，调用对应类的构造函数进行实例化，\n调用前后都可以通过一些处理器对bean进行属性的修改")]),_._v(" "),a("li",[_._v("实例化完成接下来就是初始化（依赖注入），初始化对象的属性性，初始化前后也可以通过一些处理器对属性进行一些修改")]),_._v(" "),a("li",[_._v("完成初始化之后就可以得到完整对象了，接下来将对象放入一个Map里面，后面就可以通过context.getBean获取到对应的对象了")])]),_._v(" "),a("h4",{attrs:{id:"_5-bean的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-bean的生命周期"}},[_._v("#")]),_._v(" 5. bean的生命周期")]),_._v(" "),a("p",[_._v("bean的生命周期，其实可以从bean的创建流程中窥见一二，bean的生命周期主要指的是：singleton bean(单例bean)可分为以下几个过程:")]),_._v(" "),a("ol",[a("li",[_._v("实例化，实例化一个bean对象")]),_._v(" "),a("li",[_._v("属性赋值，给bean对象设置相应的属性和依赖")]),_._v(" "),a("li",[_._v("初始化，是否实现初始化Bena接口或者配置了初始化方法，进行默认或者自定义的bean初始化")]),_._v(" "),a("li",[_._v("销毁，判断是否实现了销毁bean接口或者配置了自定义的销毁bean方法，进行默认或者自定义的bean销毁"),a("br"),_._v("\n初始化和销毁中间包含使用bean的行为，但是这一步其实不算是bean生命周期的一部分")])]),_._v(" "),a("h4",{attrs:{id:"_6-spring-security"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-spring-security"}},[_._v("#")]),_._v(" 6. spring security")]),_._v(" "),a("p",[_._v("spring security 是 spring家族中的一个安全管理框架，能与其相提并论的是apache shiro。"),a("br"),_._v("\nspring security 提供高度可定制的身份验证和授权控制管理，天然和spring集成。"),a("br"),_._v("\n主要核心内容如下：")]),_._v(" "),a("ol",[a("li",[_._v("身份认证（Authentication）")]),_._v(" "),a("li",[_._v("授权（Authorization）")]),_._v(" "),a("li",[_._v("会话管理（Session Manager）")]),_._v(" "),a("li",[_._v("加密（Cryptography）")])]),_._v(" "),a("h4",{attrs:{id:"_7-jwt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-jwt"}},[_._v("#")]),_._v(" 7. jwt")]),_._v(" "),a("p",[_._v("jwt全称Json Web Token，主要用于各方之间安全的进行json对象数据传输")]),_._v(" "),a("h4",{attrs:{id:"_8-过滤器-filter-和拦截器-interceptor-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-过滤器-filter-和拦截器-interceptor-的区别"}},[_._v("#")]),_._v(" 8. 过滤器(Filter)和拦截器(Interceptor)的区别")]),_._v(" "),a("ol",[a("li",[_._v("底层的实现原理不一样，过滤器底层是通过回调函数实现的，拦截器则是通过Java的反射机制动态代理实现的")]),_._v(" "),a("li",[_._v("使用范围不同，过滤器是依赖于servlet容器（tomcat）的属于servlet规范的一部分，而拦截器是独立的spring提供的组件可以在任何地方使用")]),_._v(" "),a("li",[_._v("触发时机不同，过滤器是请求进入容器后，但是进入servlet之前做预处理，servlet处理完之后请求结束，\n拦截器是请求进入servlet在controller之前做预处理，controller渲染了对应的视图之后请求结束")]),_._v(" "),a("li",[_._v("请求拦截范围不同，过滤器对所有进入容器的请求起作用，拦截器只针对进入controller和访问static目录下资源的请求有效")])]),_._v(" "),a("h3",{attrs:{id:"_2-springboot"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-springboot"}},[_._v("#")]),_._v(" 2. springboot")]),_._v(" "),a("h4",{attrs:{id:"_1-相较于spring的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-相较于spring的区别"}},[_._v("#")]),_._v(" 1. 相较于spring的区别")]),_._v(" "),a("p",[_._v("通过约定大于配置的框架思想，简化开发配置，可以让我们程序员更专注于业务开发，减少配置的工作")]),_._v(" "),a("h3",{attrs:{id:"_3-redis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis"}},[_._v("#")]),_._v(" 3. redis")]),_._v(" "),a("h4",{attrs:{id:"_1-支持的5个存储数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-支持的5个存储数据类型"}},[_._v("#")]),_._v(" 1. 支持的5个存储数据类型")]),_._v(" "),a("ol",[a("li",[_._v("字符串 String")]),_._v(" "),a("li",[_._v("列表 list")]),_._v(" "),a("li",[_._v("字典 hash")]),_._v(" "),a("li",[_._v("集合 set")]),_._v(" "),a("li",[_._v("有序集合Zset")])]),_._v(" "),a("h4",{attrs:{id:"_2-redis如何保证缓存刷新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis如何保证缓存刷新"}},[_._v("#")]),_._v(" 2. redis如何保证缓存刷新")]),_._v(" "),a("h4",{attrs:{id:"_3-缓存几大问题和解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-缓存几大问题和解决方案"}},[_._v("#")]),_._v(" 3. 缓存几大问题和解决方案")]),_._v(" "),a("ol",[a("li",[_._v("缓存击穿（即缓存找不到，查询数据库数据不存在，所以也没办法刷新缓存，每次都会进行数据库查询）\n"),a("ul",[a("li",[_._v("增加空值缓存，这样如果数据不存在就不会再每次都进行数据库查询")]),_._v(" "),a("li",[_._v("key值校验，例如布隆筛选器，能够大致算出key是否存在")])])]),_._v(" "),a("li",[_._v("缓存穿透（缓存过期，伴随大量对key的查询）\n"),a("ul",[a("li",[_._v("热点数据不设置过期时间")]),_._v(" "),a("li",[_._v("设置互斥锁")]),_._v(" "),a("li",[_._v("熔断降级，熔断意思设置查询不到缓存的失败次数，如果一定时间内，多次查询缓存差不多，及时失败，过一段时间再放开请求，\n降级意思是：在有限资源的情况下，暂时放弃一些功能，全力支持热点业务")])])]),_._v(" "),a("li",[_._v("缓存雪崩（同一时间大批量缓存同时过期）\n"),a("ul",[a("li",[_._v("同样热点数据不过期")]),_._v(" "),a("li",[_._v("分散缓存过期时间")])])])]),_._v(" "),a("h4",{attrs:{id:"_4-为什么使用单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-为什么使用单线程"}},[_._v("#")]),_._v(" 4. 为什么使用单线程")]),_._v(" "),a("p",[_._v("因为redis是基于内存的操作，CPU不会成为redis的瓶颈，瓶颈主要在于内存大小和网络带宽，既然单线程容易实现，并且CPU不是瓶颈，所以就采用了单线程")]),_._v(" "),a("h4",{attrs:{id:"_5-为什么redis那么快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-为什么redis那么快"}},[_._v("#")]),_._v(" 5. 为什么redis那么快？")]),_._v(" "),a("ol",[a("li",[_._v("基于内存")]),_._v(" "),a("li",[_._v("单线程，减少上下文切换同时保证原子性")]),_._v(" "),a("li",[_._v("IO多路复用")])]),_._v(" "),a("h4",{attrs:{id:"_6-先删后写还是先写后删"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-先删后写还是先写后删"}},[_._v("#")]),_._v(" 6. 先删后写还是先写后删？")]),_._v(" "),a("p",[_._v("一般是先写后删，因为先删后写容易出现脏数据，虽然会出现一致性的问题，但是不影响后续的查询")]),_._v(" "),a("h4",{attrs:{id:"_7-应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-应用场景"}},[_._v("#")]),_._v(" 7. 应用场景")]),_._v(" "),a("ol",[a("li",[_._v("string，一般用于限流、分布式锁、缓存")]),_._v(" "),a("li",[_._v("hash，用户信息、组合查询")]),_._v(" "),a("li",[_._v("list，简单队列")]),_._v(" "),a("li",[_._v("Set，赞、踩、标签")]),_._v(" "),a("li",[_._v("ZSet，排行榜")])]),_._v(" "),a("h4",{attrs:{id:"_8-redis怎样实现高并发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-redis怎样实现高并发"}},[_._v("#")]),_._v(" 8. redis怎样实现高并发")]),_._v(" "),a("p",[_._v("通过主从加集群架构，实现读写分离，主节点负责缓存写入和同步给子节点，子节点负责读数据，实现高并发")]),_._v(" "),a("h4",{attrs:{id:"_9-redis怎样保证原子性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-redis怎样保证原子性"}},[_._v("#")]),_._v(" 9. redis怎样保证原子性")]),_._v(" "),a("p",[_._v("因为redis是单线程，所以他提供的api也是原子操作，只不过我们业务中通常先get再set会出现数据不一致，可以通过加锁亦或者使用Lua脚本实现CAS操作")]),_._v(" "),a("h4",{attrs:{id:"_10-redis事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-redis事务"}},[_._v("#")]),_._v(" 10. redis事务")]),_._v(" "),a("p",[_._v("redis的事务本质是一组命令的集合，事务按顺序一次执行多个命令，但是没有事务隔离级别也不保证事务的原子性")]),_._v(" "),a("h4",{attrs:{id:"_11-redis一个字符串能够存储的最大容量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-redis一个字符串能够存储的最大容量"}},[_._v("#")]),_._v(" 11. redis一个字符串能够存储的最大容量")]),_._v(" "),a("p",[_._v("512M")]),_._v(" "),a("h4",{attrs:{id:"_12-redis其他内容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-redis其他内容"}},[_._v("#")]),_._v(" 12. redis其他内容")]),_._v(" "),a("ol",[a("li",[_._v("redis6之前使用的是单线程，之后引入了多线程")]),_._v(" "),a("li",[_._v("引入多线程，是因为单线程没办法充分利用CPU的资源")]),_._v(" "),a("li",[_._v("多线程可以分担redis的IO读写同步负荷")]),_._v(" "),a("li",[_._v("redis使用惰性删除和定期删除的策略处理过期数据，惰性删除是每次查找key的先检查是否过期，过期则删除再执行对应操作。定期删除：核心是指定个数的每一个库随机删除小于等于指定个数的key")]),_._v(" "),a("li",[_._v("redis虽然引入了多线程，但是默认是关闭的，还是使用的单线程，要使用多线程需要主动配置")]),_._v(" "),a("li",[_._v("redis的多线程部分只是用来处理网络数据的读写和协议解析，具体命令还是单线程顺序执行，所以我们不需要考虑线程安全问题")]),_._v(" "),a("li",[_._v("可以通过setnx方法判断结果等于1来判断缓存不存在，实现对应分分布式锁，缓存值可以是过期时间，防止出现永久锁")])]),_._v(" "),a("h3",{attrs:{id:"_4-rabbitmq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-rabbitmq"}},[_._v("#")]),_._v(" 4. rabbitMQ")]),_._v(" "),a("p",[_._v("rabbitMQ是实现了高级消息队列协议的开源消息代理软件，也是俗称面向消息的中间件。")]),_._v(" "),a("h4",{attrs:{id:"_1-rabbitmq的主要用途"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-rabbitmq的主要用途"}},[_._v("#")]),_._v(" 1. rabbitMQ的主要用途")]),_._v(" "),a("p",[_._v("一般来说我们使用到消息队列的三个用途是：异步处理、服务解耦、流量控制（也就是俗称的削峰）")]),_._v(" "),a("h4",{attrs:{id:"_2-rabbitmq-如何保证消息可靠"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-rabbitmq-如何保证消息可靠"}},[_._v("#")]),_._v(" 2.rabbitMQ 如何保证消息可靠")]),_._v(" "),a("ol",[a("li",[_._v("生产者到MQ，可通过事务机制亦或者confirm（确认机制）来保证消息完整性，一般生产环境使用confirm（确认机制）")]),_._v(" "),a("li",[_._v("MQ自身，可以通过持久化、集群、普通模式、镜像模式来保证消息不会丢失")]),_._v(" "),a("li",[_._v("MQ到消费者，可以通过basicAck机制、死信队列、消息补偿机制，确保消息被正常消费")])]),_._v(" "),a("h4",{attrs:{id:"_3-死信队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-死信队列"}},[_._v("#")]),_._v(" 3. 死信队列")]),_._v(" "),a("p",[_._v("当一个消息在队列中变成死信的时候，就会被发送到DLX，死信交换器中，绑定DLX的队列就是死信队列。一下几种情况一让消息变成死信：")]),_._v(" "),a("ol",[a("li",[_._v("消息被拒绝")]),_._v(" "),a("li",[_._v("消息过期时间（TTL）过期")]),_._v(" "),a("li",[_._v("队列满了无法再添加")])]),_._v(" "),a("h4",{attrs:{id:"_4-rabbitmq中消息有几种状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-rabbitmq中消息有几种状态"}},[_._v("#")]),_._v(" 4. rabbitMQ中消息有几种状态？")]),_._v(" "),a("ol",[a("li",[_._v("消息内容和消息索引都存储在内存中")]),_._v(" "),a("li",[_._v("消息内容在磁盘中，消息索引在内存中")]),_._v(" "),a("li",[_._v("消息内容在磁盘中，消息索引内存和磁盘中都有")]),_._v(" "),a("li",[_._v("消息内容和索引都在磁盘中")])]),_._v(" "),a("h4",{attrs:{id:"_5-生产者如何将消息可靠投递到mq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-生产者如何将消息可靠投递到mq"}},[_._v("#")]),_._v(" 5. 生产者如何将消息可靠投递到MQ？")]),_._v(" "),a("p",[_._v("MQ有确认机制，客户端发送消息给MQ之后，MQ持久化完成会返回一个Ask给客户端，确认消息已经投递到MQ，如果客户端超时没有受到MQ的确认，会重发消息")]),_._v(" "),a("h4",{attrs:{id:"_6-mq如何将消息可靠投递到消费者"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-mq如何将消息可靠投递到消费者"}},[_._v("#")]),_._v(" 6. MQ如何将消息可靠投递到消费者？")]),_._v(" "),a("p",[_._v("MQ将消息推送给客户端，客户端得到消息完成业务后，返回一个Ask给MQ，MQ确认消息被消费后删除消息，其次可以通过保证消息幂等性，处理MQ没能受到确认信息的问题"),a("br"),_._v("\n消息幂等性：即，消息消费一次或多次产生的影响相同")]),_._v(" "),a("h4",{attrs:{id:"_7-如何确保mq高可用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何确保mq高可用"}},[_._v("#")]),_._v(" 7. 如何确保MQ高可用？")]),_._v(" "),a("p",[_._v("采用镜像集群模式。MQ有三种模式，单机模式、普通集群模式、镜像集群模式，集群部署区分磁盘节点和内存节点，内存节点不会将消息持久化到磁盘，只存储在内存中，磁盘节点会持久化消息到磁盘和保存在内存中，MQ集群至少存在一个磁盘节点")]),_._v(" "),a("ol",[a("li",[_._v("单机模式，一般只用于本地，亦或者少量应用于一些小的项目")]),_._v(" "),a("li",[_._v("普通集群模式，在多个机器上启动MQ实例，集群部署，这个模式创建的队列只保存在主节点中，其他节点如果查询的不是本节点的数据需要去主节点拉取数据")]),_._v(" "),a("li",[_._v("镜像集群模式，MQ的高可用模式，和普通集群不用的是，创建的队列和队列消息内容和元数据会同步到多个实例，普通集群只同步元数据")])]),_._v(" "),a("h4",{attrs:{id:"_8-集群中唯一的磁盘节点崩溃了"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-集群中唯一的磁盘节点崩溃了"}},[_._v("#")]),_._v(" 8. 集群中唯一的磁盘节点崩溃了")]),_._v(" "),a("p",[_._v("集群中唯一的磁盘节点崩溃了，集群还可以运行，但是不能更改任何东西")]),_._v(" "),a("ol",[a("li",[_._v("不能创建队列、交换器、绑定")]),_._v(" "),a("li",[_._v("不能添加用户和更该权限")]),_._v(" "),a("li",[_._v("不能添加删除节点")])]),_._v(" "),a("h4",{attrs:{id:"_9-如何保证消息有序性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-如何保证消息有序性"}},[_._v("#")]),_._v(" 9. 如何保证消息有序性？")]),_._v(" "),a("p",[_._v("拆分队列，因为MQ内部队列是先进先出的，只需要保证队列只对应一个消费者，将消息按序传递到对应的队列即可")]),_._v(" "),a("h3",{attrs:{id:"_5-mybatis"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-mybatis"}},[_._v("#")]),_._v(" 5. mybatis")]),_._v(" "),a("h4",{attrs:{id:"_1-分页插件实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-分页插件实现原理"}},[_._v("#")]),_._v(" 1. 分页插件实现原理")]),_._v(" "),a("p",[_._v("通过sql拦截，在sql尾部添加分页查询条件")]),_._v(" "),a("h2",{attrs:{id:"_7-开发工具和管理插件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-开发工具和管理插件"}},[_._v("#")]),_._v(" 7. 开发工具和管理插件")]),_._v(" "),a("h3",{attrs:{id:"_1-maven-常用命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-maven-常用命令"}},[_._v("#")]),_._v(" 1. maven 常用命令")]),_._v(" "),a("ol",[a("li",[_._v("mvn clean 清理项目")]),_._v(" "),a("li",[_._v("mvn package 打包")]),_._v(" "),a("li",[_._v("mvn install 打包当前项目为jar包生成在本地仓库，以供其他项目使用")]),_._v(" "),a("li",[_._v("mvn test 对项目进行运行测试")]),_._v(" "),a("li",[_._v("mvn compile 编译项目源代码")])]),_._v(" "),a("h3",{attrs:{id:"_2-git和svn的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-git和svn的区别"}},[_._v("#")]),_._v(" 2. git和svn的区别")]),_._v(" "),a("ol",[a("li",[_._v("git不联网也可以提交到本地仓库，svn必须联网才能提交")]),_._v(" "),a("li",[_._v("git的权限管理不是很方便，svn有较好的权限管理功能")]),_._v(" "),a("li",[_._v("git是分布式的，每个成员都有自己的完整仓库，svn是集中式的，如果中心服务器出问题所有人都不能干活")]),_._v(" "),a("li",[_._v("git没有全局的版本号，svn有")]),_._v(" "),a("li",[_._v("git的内容完整新要优于svn,因为git内存存储使用的是SHA-1哈希算法，这能更大程度确保内容的完整性")])]),_._v(" "),a("h2",{attrs:{id:"_8-数据库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-数据库"}},[_._v("#")]),_._v(" 8. 数据库")]),_._v(" "),a("h3",{attrs:{id:"_1-索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-索引"}},[_._v("#")]),_._v(" 1. 索引")]),_._v(" "),a("p",[_._v("索引，其实个人理解，索引分为主索引和辅助索引，主索引指的是主键索引、辅助索引则是比如单例索引、复合索引、唯一索引等。\n其他的索引分类有，聚簇索引和非聚簇索引，亦或者聚集索引和非聚集索引，其实主要说的都是主索引和其他索引的区分")]),_._v(" "),a("ol",[a("li",[_._v("主键索引"),a("br"),_._v("\n主键索引其实有分聚簇索引、非聚簇索引，聚集索引、非聚集索引，聚簇索引索引说的是一种数据存储方式，将数据和索引放在一起，而非聚簇索引也就是相反不放在一起的情况。\n聚集索引说的是表中数据排序方式和索引排序方式保持一致，非聚集索引也就是排序不一致的情况。")]),_._v(" "),a("li",[_._v("辅助索引"),a("br"),_._v("\n其实说的是单例索引、复合索引、唯一索引等索引，如果主键索引是聚簇索引索引，那么辅助索引存储的不再是记录的具体物理地址而是主键索引值，MySQL的innoDB主键默认的索引就是聚簇索引。\n辅助索引的查询是需要进行二次查找的，先找到辅助索引的对应主键索引值，然后再到主键索引树找到对应数据。MyIsam存储索引默认主键是非聚簇索引和innoDB相反，不过相对来说虽然辅助索引\n需要进行两次查找找到对应数据，但是MyIsam不使用聚簇索引，反而需要进行更多的IO读取操作。\n"),a("ul",[a("li",[_._v("唯一索引"),a("br"),_._v("\n索引列的值必须唯一，但是允许有空值")]),_._v(" "),a("li",[_._v("单例索引"),a("br"),_._v("\n一个索引只包含单列，一个表可以有多个单列索引")]),_._v(" "),a("li",[_._v("复合索引"),a("br"),_._v("\n一个索引包含多列，相对来说如果查询条件有多个的话，复合索引比单例索引所需开销更小")])])])]),_._v(" "),a("h3",{attrs:{id:"_2-数据库三大范式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据库三大范式"}},[_._v("#")]),_._v(" 2. 数据库三大范式")]),_._v(" "),a("ol",[a("li",[_._v("每个属性列都是不可分割的原子项")]),_._v(" "),a("li",[_._v("满足第一范式的情况下，不存在部分依赖，即所有非主键属性都完全依赖于主键属性")]),_._v(" "),a("li",[_._v("满足第二范式的情况下，不存在依赖传递，即非主键属性不能和非主键属性存在依赖")])]),_._v(" "),a("h3",{attrs:{id:"_3-事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-事务"}},[_._v("#")]),_._v(" 3. 事务")]),_._v(" "),a("p",[_._v("事务存在ACID特性，也就是原子性：保证每次提交都是不可分割的，要么全部成功，要么全部失败、一致性：事务的执行结果必须从一个一致性状态到另一个一致性状态，即提交前后的数据综合状态不变、\n隔离性：并发执行的事务不会相互影响、持久性：事务一旦提交，数据库的更新就是永久的")]),_._v(" "),a("ul",[a("li",[_._v("事务隔离级别，从低到高，事务的隔离级别越低,可能出现的并发异常越多")])]),_._v(" "),a("ol",[a("li",[_._v("读未提交(READ UNCOMMITTED)\n脏读：脏读是指一个事务读取了另一个事务未提交的数据")]),_._v(" "),a("li",[_._v("读已提交(READ COMMITTED)\n可避免脏读，但是存在幻读：幻读是指事务读取某个范围的数据时，因为其他事务的操作导致前后两次读取的结果不一致，主要在于记录数量的不同。\n还有不可重复读：对于两个事务T1,T2，T1读取了一个字段，然后T2更新了该字段之后，T1在读取同一个字段，值就不同了")]),_._v(" "),a("li",[_._v("可重复读(REPEATABLE READ)（MySQL默认事务隔离级别）\n可避免不可重复度，但是幻读还是存在")]),_._v(" "),a("li",[_._v("串行化(SERIALIZABLE)\n最高级别，基本没有并发异常")])]),_._v(" "),a("h3",{attrs:{id:"_4-数据库编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-数据库编程"}},[_._v("#")]),_._v(" 4. 数据库编程")]),_._v(" "),a("h3",{attrs:{id:"_5-删除表中所有行数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-删除表中所有行数据"}},[_._v("#")]),_._v(" 5. 删除表中所有行数据")]),_._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 第一种方式，删除表中所有行，不记录单个行删除操作")]),_._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("TRUNCATE")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("TABLE")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")]),_._v("table_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[_._v("# 第二种方式，使用删除语句")]),_._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("DELETE")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("FROM")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token identifier"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")]),_._v("table_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("`")])]),_._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("where")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[_._v("1")]),a("br"),a("span",{staticClass:"line-number"},[_._v("2")]),a("br"),a("span",{staticClass:"line-number"},[_._v("3")]),a("br"),a("span",{staticClass:"line-number"},[_._v("4")]),a("br")])]),a("h3",{attrs:{id:"_6-innodb和myisam的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-innodb和myisam的区别"}},[_._v("#")]),_._v(" 6. innodb和MyISAM的区别")]),_._v(" "),a("ol",[a("li",[_._v("innodb支持表级锁和行级锁MyISAM只支持表级锁")]),_._v(" "),a("li",[_._v("innodb支持事务MyISAM不支持")]),_._v(" "),a("li",[_._v("innodb支持外键MyISAM不支持")]),_._v(" "),a("li",[_._v("innodb支持数据库崩溃后安全恢复MyISAM不支持")]),_._v(" "),a("li",[_._v("innodb默认的主键索引是聚簇索引，MyISAM是非聚簇索引")])]),_._v(" "),a("h3",{attrs:{id:"_7-数据库的最左匹配原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-数据库的最左匹配原则"}},[_._v("#")]),_._v(" 7. 数据库的最左匹配原则")]),_._v(" "),a("blockquote",[a("p",[_._v("最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。\n因为建立复合索引也就是多列索引的时候，MySQL会根据建立的索引顺序，对索引进行排序，从左边开始，如果想要使用到这个索引进行快速的查找，\n那么查询条件也必须遵循最左优先的连续原则")])]),_._v(" "),a("h3",{attrs:{id:"_8-常见的数据模型和逻辑模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-常见的数据模型和逻辑模型"}},[_._v("#")]),_._v(" 8. 常见的数据模型和逻辑模型")]),_._v(" "),a("ol",[a("li",[_._v("常见的数据模型有：概念模型、逻辑模型、物理模型")]),_._v(" "),a("li",[_._v("常见的逻辑模型有：层次模型、网状模型、关系模型")])]),_._v(" "),a("h2",{attrs:{id:"_9-前端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-前端"}},[_._v("#")]),_._v(" 9. 前端")]),_._v(" "),a("h3",{attrs:{id:"_1-元素节点的获取方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-元素节点的获取方式"}},[_._v("#")]),_._v(" 1. 元素节点的获取方式")]),_._v(" "),a("p",[_._v("document提供几种方式获取元素节点，比如标签名称、name属性、class样式名、元素id属性。")]),_._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[_._v("document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[_._v("getElementsByTagName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\ndocument"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[_._v("getElementsByName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\ndocument"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[_._v("getElementsByClassName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\ndocument"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[_._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])]),_._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[_._v("1")]),a("br"),a("span",{staticClass:"line-number"},[_._v("2")]),a("br"),a("span",{staticClass:"line-number"},[_._v("3")]),a("br"),a("span",{staticClass:"line-number"},[_._v("4")]),a("br")])]),a("p",[_._v("亦或者直接通过jquery选择器$()，也是可以通过标签名称、name属性、class样式名、元素id属性获取元素节点")]),_._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[_._v("$")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[_._v("'div'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[_._v("$")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[_._v("'div[name=\"\"]'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[_._v("$")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[_._v("'div.active'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[_._v("$")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[_._v("'#id'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n")])]),_._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[_._v("1")]),a("br"),a("span",{staticClass:"line-number"},[_._v("2")]),a("br"),a("span",{staticClass:"line-number"},[_._v("3")]),a("br"),a("span",{staticClass:"line-number"},[_._v("4")]),a("br")])]),a("h3",{attrs:{id:"_2-箭头函数和普通函数的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-箭头函数和普通函数的区别"}},[_._v("#")]),_._v(" 2. 箭头函数和普通函数的区别")]),_._v(" "),a("ol",[a("li",[_._v("写法不同")]),_._v(" "),a("li",[_._v("箭头函数中的this指向不同，它的this是父级普通函数的this.")]),_._v(" "),a("li",[_._v("箭头函数不能用于构造函数，普通函数可以")])]),_._v(" "),a("h3",{attrs:{id:"_3-undefined和null的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-undefined和null的区别"}},[_._v("#")]),_._v(" 3. undefined和null的区别")]),_._v(" "),a("ul",[a("li",[_._v("undefined\n未定义的值，表示一个变量最原始的状态")]),_._v(" "),a("li",[_._v("null\n空值，一个对象被人为的置为空对象")]),_._v(" "),a("li",[_._v("不同点")])]),_._v(" "),a("ol",[a("li",[_._v("undefined是JavaScript的一个全局变量，null只是JavaScript的一个关键字")]),_._v(" "),a("li",[_._v("进行类型检查也就是typeof运算时，undefined返回undefined，null会返回object")]),_._v(" "),a("li",[_._v("在进行数值类型转换时undefined，会转换成NaN无法参与计算，null可以转换成0参与计算")])]),_._v(" "),a("h3",{attrs:{id:"_4-判断类型的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-判断类型的方法"}},[_._v("#")]),_._v(" 4. 判断类型的方法")]),_._v(" "),a("ol",[a("li",[_._v("通过typeof进行判断亦或者instanceof判断，其中typeof判断object、array、null都会返回object")]),_._v(" "),a("li",[_._v("亦或者通过构造函数名，使用对应的对象调用此方法返回类型 constructor.name")]),_._v(" "),a("li",[_._v("最后还可以通过属性的转成字符串的方式，比如调用对象的prototype.toString()方法返回属性类型字符串，会带上Object")])]),_._v(" "),a("h3",{attrs:{id:"_5-事件冒泡机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-事件冒泡机制"}},[_._v("#")]),_._v(" 5. 事件冒泡机制")]),_._v(" "),a("p",[_._v("当元素触发事件时，事件会从window中一层一层的往下寻找触发元素，找到目标元素后又回到window，\n这个过程分为两个阶段，一个是捕获阶段，也就是事件会从window中一层一层的往下寻找触发元素，另一个是冒泡阶段，也就是找到目标元素后又回到window的过程\n如果不想进行事件冒泡可以通过调用event.stopPropagation();停止冒泡。\n参考事件原理："),a("a",{attrs:{href:"https://www.cnblogs.com/bfgis/p/5460191.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("原理"),a("OutboundLink")],1)]),_._v(" "),a("h2",{attrs:{id:"_1-linux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-linux"}},[_._v("#")]),_._v(" 1. Linux")]),_._v(" "),a("h3",{attrs:{id:"_1-查询日志后十行的命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-查询日志后十行的命令"}},[_._v("#")]),_._v(" 1. 查询日志后十行的命令")]),_._v(" "),a("div",{staticClass:"language-shell script line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[_._v("tail")]),_._v(" -f -n -10 /DumpStack.log\n")])]),_._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[_._v("1")]),a("br")])]),a("h2",{attrs:{id:"_11-网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-网络"}},[_._v("#")]),_._v(" 11. 网络")]),_._v(" "),a("h3",{attrs:{id:"_1-tcp和udp的定义和区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-tcp和udp的定义和区别"}},[_._v("#")]),_._v(" 1. TCP和UDP的定义和区别")]),_._v(" "),a("ul",[a("li",[_._v("TCP\n定义：TCP 是一种面向链接，可靠的基于字节流的传输层通信协议。\n"),a("ol",[a("li",[_._v("TCP协议将数据切割成多个小片段，每个片段由header头和数据payload组成，为了确保数据顺序，会给每个片段一个序列号，方便后期堆序列号进行排序")]),_._v(" "),a("li",[_._v("面向链接：三次握手确保链接正常")]),_._v(" "),a("li",[_._v("可靠，传输前进行确认，传输时还有确认、窗口、重传、拥塞控制等机制确保数据可靠")]),_._v(" "),a("li",[_._v("基于字节流，可以理解为一个双向通道里面流淌的二进制数据也就是01串，纯裸的TCP是没有边界的，也就是你根本不知道从哪个地方开始到那个地方结束的01串是一条完整的信息，所以说纯裸的TCP是不能直接拿来用的，\n你需要在传输的信息中加入自定义规则用来区分消息边界")]),_._v(" "),a("li",[_._v("于是基于TCP就衍生了许多的协议，比如HTTP和RPC")])])]),_._v(" "),a("li",[_._v("UDP\n定义：UDP是一种无连接，基于数据报文的传输层通信协议")]),_._v(" "),a("li",[_._v("区别")])]),_._v(" "),a("ol",[a("li",[_._v("TCP传输前需要建立链接，UDP不需要")]),_._v(" "),a("li",[_._v("因为建立链接的关系，TCP的传输效率低于UDP")]),_._v(" "),a("li",[_._v("TCP的传输是可靠的，因为在数据传输前TCP会进行三次握手，传输时还会由确认、窗口、重传、拥塞控制等机制，因此通过TCP传输的数据可以保证数据的完整性、不重复、按序到达")]),_._v(" "),a("li",[_._v("UDP 传输时，接受主机不需要给出确认也不保证数据是否完整、按序抵达")])]),_._v(" "),a("ul",[a("li",[_._v("应用场景")])]),_._v(" "),a("blockquote",[a("p",[_._v("UDP一般应用即时通信，比如语音、视频、直播等，这些场景对数据的准确性要求不是特别高，比如视频丢失了一两帧其实看起来没太大区别")])]),_._v(" "),a("blockquote",[a("p",[_._v("TCP一般应用于对传输数据准确性要求较高的场景，比如文件传输、远程登录、邮件等")])]),_._v(" "),a("h3",{attrs:{id:"_2-http和rpc的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-http和rpc的区别"}},[_._v("#")]),_._v(" 2. HTTP和RPC的区别")]),_._v(" "),a("p",[_._v("基于字节流的TCP协议，可以理解为一个双向通道里面流淌的二进制数据也就是01串，纯裸的TCP是没有收发的01串是没有边界的，也就是你根本不知道从哪个地方开始到那个地方结束的01串是一条完整的信息，\n所以说纯裸的TCP是不能直接拿来用的，你需要在传输的信息中加入自定义规则用来区分消息边界，于是基于TCP就衍生了许多的协议，比如HTTP和RPC，它们都是基于TCP定义了不同消息格式的应用层传输协议")]),_._v(" "),a("blockquote",[a("p",[_._v("TCP 是70年代出来的，HTTP是90年代出来的，而中间80年代RPC就已经出现了，那么为什么有了RPC还要有HTTP呢？HTTP的应用为什么这么广泛，这就要追究到一个东西就是浏览器（browser），\n浏览器不只需要链接自家的服务器还要和其他的服务器进行通信，那势必需要一个统一的通信协议，所以HTTP就诞生了，而原有的RPC并不是说没有用了，而是更多的转向了企业内部，而不是对外。")])]),_._v(" "),a("ul",[a("li",[_._v("HTTP\n定义：超文本传输协议")]),_._v(" "),a("li",[_._v("RPC\n定义：RPC其实是一种调用方式，又叫远程调用。值得注意的是RPC基于TCP协议，但是它不一定非得使用TCP，它的底层可以替换成UDP亦或者HTTP")])]),_._v(" "),a("h3",{attrs:{id:"_3-七层网络协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-七层网络协议"}},[_._v("#")]),_._v(" 3. 七层网络协议")]),_._v(" "),a("p",[_._v("从上到下分别是")]),_._v(" "),a("ol",[a("li",[_._v("应用层  ，http、RPC协议")]),_._v(" "),a("li",[_._v("表示层")]),_._v(" "),a("li",[_._v("会话层  ，前三层做四层区分的时候叫统称应用层")]),_._v(" "),a("li",[_._v("传输层  ，TCP、UDP协议")]),_._v(" "),a("li",[_._v("网络层")]),_._v(" "),a("li",[_._v("数据链路层 ，网络层和数据链路层做四层区分的时候统称网络层")]),_._v(" "),a("li",[_._v("物理层")])])])}),[],!1,null,null,null);a.default=s.exports}}]);