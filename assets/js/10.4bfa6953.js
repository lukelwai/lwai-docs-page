(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{380:function(a,t,s){"use strict";s.r(t);var r=s(2),e=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"封装、继承、多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装、继承、多态"}},[a._v("#")]),a._v(" 封装、继承、多态")]),a._v(" "),t("h2",{attrs:{id:"封装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[a._v("#")]),a._v(" 封装")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("利用抽象数据类型，将属性和操作方法封装成一个整体，对外隐藏内部的实现细节，\n只保留一些对外的功能接口。\n")])])]),t("h2",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[a._v("#")]),a._v(" 继承")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("继承就是保持已有类的特性，构造新类的过程。继承后子类可以调用父类中非私有的属性和方法。\n")])])]),t("h2",{attrs:{id:"多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[a._v("#")]),a._v(" 多态")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("多态的定义其实有点抽象，但也可以进行简单理解。\nJava中多态，分为编译时多态和运行时多态。编译时多态指的是方法的重载，是静态的。\n运行时多态指的主要时方法的重写。因为程序中定义的引用变量所指定的引用类型和通过该引用变量发出的方法调用，其实在编译期还不确定，只有程序在运行时\n才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法。\n有点类似于薛定谔的猫，在静止未观测状态的时候状态是未知的，只有进行观察之后量子塌缩成形，状态才确定下来，变成我们可识别的状态\n")])])]),t("h3",{attrs:{id:"多态实现机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态实现机制"}},[a._v("#")]),a._v(" 多态实现机制")]),a._v(" "),t("p",[a._v("多态的实现机制，硬说的话可以说是继承。然后Java中要实现多态有三个必要的条件，分别是：")]),a._v(" "),t("ol",[t("li",[a._v("继承")]),a._v(" "),t("li",[a._v("重写")]),a._v(" "),t("li",[a._v("向上转型")])])])}),[],!1,null,null,null);t.default=e.exports}}]);