(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{390:function(e,t,a){"use strict";a.r(t);var n=a(2),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("参考：[常见并发面试题](https://blog.csdn.net/t4i2b10X4c22nF6A/article/details/105803323?ops_request_misc=%257B%2522request\n%255Fid%2522%253A%2522166108915716781432980720%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166108915716781432980720&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-105803323-null-null.142^v42^new_blog_pos_by_title,185^v2^tag_show&utm_term=java%20%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187)")]),e._v(" "),t("h1",{attrs:{id:"常见的并发知识点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见的并发知识点"}},[e._v("#")]),e._v(" 常见的并发知识点")]),e._v(" "),t("ol",[t("li",[e._v("线程和进程有什么区别？\n线程是进程的子集，一个进程可以有很多线程。每个进程都有自己的内存空间，可执行代码和唯一进程标识符（PID）。")])]),e._v(" "),t("p",[e._v("每条线程并行执行不同的任务。不同的进程使用不同的内存空间（线程自己的堆栈），而所有的线程共享一片相同的内存空间（进程主内存）。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。")]),e._v(" "),t("ol",[t("li",[e._v("实现多线程的方式有哪些？\n继承Thread类：Java单继承，不推荐；")])]),e._v(" "),t("p",[e._v("实现Runnable接口：Thread类也是继承Runnable接口，推荐；")]),e._v(" "),t("p",[e._v("实现Callable接口：实现Callable接口，配合FutureTask使用，有返回值；")]),e._v(" "),t("p",[e._v("使用线程池：复用，节约资源；")]),e._v(" "),t("ol",[t("li",[e._v("用Runnable还是Thread？\n这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。")])]),e._v(" "),t("p",[e._v("Runnable和Thread两者最大的区别是Thread是类而Runnable是接口，至于用类还是用接口，取决于继承上的实际需要。Java类是单继承的，实现多个接口可以实现类似多继承的操作。")]),e._v(" "),t("p",[e._v("其次， Runnable就相当于一个作业，而Thread才是真正的处理线程，我们需要的只是定义这个作业，然后将作业交给线程去处理，这样就达到了松耦合，也符合面向对象里面组合的使用，另外也节省了函数开销，继承Thread的同时，不仅拥有了作业的方法run()，还继承了其他所有的方法。")]),e._v(" "),t("p",[e._v("当需要创建大量线程的时候，有以下不足：①线程生命周期的开销非常高；②资源消耗；③稳定性。")]),e._v(" "),t("p",[e._v("如果二者都可以选择不用，那就不用。因为Java这门语言发展到今天，在语言层面提供的多线程机制已经比较丰富且高级，完全不用在线程层面操作。直接使用Thread和Runnable这样的“裸线程”元素比较容易出错，还需要额外关注线程数等问题。建议：简单的多线程程序，使用Executor。复杂的多线程程序，使用一个Actor库，首推Akka。")]),e._v(" "),t("p",[e._v("如果一定要在Runnable和Thread中选择一个使用，选择Runnable。")]),e._v(" "),t("ol",[t("li",[e._v("Thread 类中的start() 和 run() 方法有什么区别？\n这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，JDK 1.8源码中start方法的注释这样写到：Causes this thread to begin execution; the Java Virtual Machine calls the "),t("code",[e._v("run")]),e._v(" method of this thread.这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程，JDK 1.8源码中注释这样写：The result is that two threads are running concurrently: the current thread (which returns from the call to the "),t("code",[e._v("start")]),e._v(" method) and the other thread (which executes its "),t("code",[e._v("run")]),e._v(" method).。")])]),e._v(" "),t("p",[e._v("new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。")]),e._v(" "),t("p",[e._v("总结：调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。")]),e._v(" "),t("ol",[t("li",[e._v("说说 sleep() 方法和 wait() 方法区别和共同点?\n两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。")])]),e._v(" "),t("p",[e._v("两者都可以暂停线程的执行。")]),e._v(" "),t("p",[e._v("Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。")]),e._v(" "),t("p",[e._v("wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。")]),e._v(" "),t("ol",[t("li",[e._v("说说并发与并行的区别?\n并发：同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；")])]),e._v(" "),t("p",[e._v("并行：单位时间内，多个任务同时执行。")]),e._v(" "),t("ol",[t("li",[e._v("说说线程的生命周期和状态?")])])])}),[],!1,null,null,null);t.default=r.exports}}]);