(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{392:function(r,t,_){"use strict";_.r(t);var s=_(2),v=Object(s.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h2",{attrs:{id:"_1-disruptor是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-disruptor是什么"}},[r._v("#")]),r._v(" 1. Disruptor是什么？")]),r._v(" "),t("p",[r._v("Disruptor是一种高性能的并发编程框架，专门用于解决多线程并发访问共享资源时的性能瓶颈问题。\n它是由LMAX（一家金融交易平台提供商）开发的，旨在处理高并发的金融交易数据。\nDisruptor的设计目标是提供极低的延迟和高吞吐量，使其适用于需要高性能和低延迟的应用场景，\n如金融交易系统、游戏引擎、通信中间件等。")]),r._v(" "),t("blockquote",[t("p",[r._v("个人理解：相比于正常创建自己的线程池去开启多个线程处理数据，Disruptor框架的优势是环形缓冲区和无锁设计，能够减少正常多线程的线程切换和锁竞争消耗，\n提高并发性能和系统吞吐量，所以当需要设计和处理一些调度大数据量的内容追求性能和吞吐量的时候，就可以考虑这个框架，\n并且Disruptor框架和spring集成也很简单")])]),r._v(" "),t("h2",{attrs:{id:"_2-特性组成结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-特性组成结构"}},[r._v("#")]),r._v(" 2. 特性组成结构")]),r._v(" "),t("p",[r._v("以下是Disruptor的一些关键特点和概念：")]),r._v(" "),t("ol",[t("li",[t("strong",[r._v("环形缓冲区（Ring Buffer）：")]),r._v(" Disruptor使用环形缓冲区作为数据的存储和传递介质。环形缓冲区的大小是固定的，所有的数据都按照顺序存储在环上的不同位置。这种设计允许高效的读写操作，减少了锁竞争。")]),r._v(" "),t("li",[t("strong",[r._v("事件（Event）：")]),r._v(" Disruptor中的数据单元被称为事件。事件是要在不同的生产者和消费者之间传递的信息单元。")]),r._v(" "),t("li",[t("strong",[r._v("生产者（Producer）：")]),r._v(" 生产者是负责向环形缓冲区中发布事件的线程或组件。多个生产者可以并发地发布事件。")]),r._v(" "),t("li",[t("strong",[r._v("消费者（Consumer）：")]),r._v(" 消费者是负责从环形缓冲区中读取和处理事件的线程或组件。多个消费者可以并发地处理事件。")]),r._v(" "),t("li",[t("strong",[r._v("序列（Sequence）：")]),r._v(" 序列是一种用于跟踪生产者和消费者进度的机制。每个生产者和消费者都有一个序列，用于标识它们在环形缓冲区中的位置。")]),r._v(" "),t("li",[t("strong",[r._v("屏障（Barrier）：")]),r._v(" 屏障是一种同步机制，用于控制生产者和消费者之间的事件传递。生产者在发布事件之前必须等待消费者的屏障，消费者在处理事件之前必须等待生产者的屏障。")]),r._v(" "),t("li",[t("strong",[r._v("消费者组（Consumer Group）：")]),r._v(" 多个消费者可以组成一个消费者组，共同处理事件。每个消费者组有一个独立的屏障。")]),r._v(" "),t("li",[t("strong",[r._v("无锁设计：")]),r._v(" Disruptor的设计目标之一是避免使用锁，以减少多线程竞争和锁带来的性能开销。它使用CAS（比较并交换）等无锁算法来实现高性能。")])]),r._v(" "),t("h2",{attrs:{id:"_3-线程组成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程组成"}},[r._v("#")]),r._v(" 3. 线程组成")]),r._v(" "),t("p",[r._v("主要的多线程组件包括：")]),r._v(" "),t("ol",[t("li",[t("p",[t("strong",[r._v("生产者线程：")]),r._v(" 生产者线程负责发布事件到Disruptor的环形缓冲区。生产者线程可以是单个线程或多个线程并发发布事件。")])]),r._v(" "),t("li",[t("p",[t("strong",[r._v("消费者线程：")]),r._v(" 消费者线程负责从Disruptor的环形缓冲区中读取事件并进行处理。通常会有多个消费者线程并行处理事件，以提高处理吞吐量。")])]),r._v(" "),t("li",[t("p",[t("strong",[r._v("Disruptor框架线程：")]),r._v(" Disruptor框架本身会创建一些后台线程来管理环形缓冲区的状态和协调生产者与消费者之间的事件传递。")])]),r._v(" "),t("li",[t("p",[t("strong",[r._v("线程池：")]),r._v(" 在一些高度定制化的Disruptor应用中，你可以使用自己的线程池来执行事件处理器中的逻辑。")])])]),r._v(" "),t("p",[r._v("Disruptor通过无锁设计和数据分离等技术来减少线程之间的竞争条件，以提高性能。它的核心思想是使用环形缓冲区，不需要锁来保护缓冲区的读写操作，从而避免了多线程锁竞争带来的性能瓶颈。")])])}),[],!1,null,null,null);t.default=v.exports}}]);