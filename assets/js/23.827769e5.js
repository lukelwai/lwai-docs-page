(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{395:function(_,v,l){"use strict";l.r(v);var a=l(2),t=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"_23个设计模式-默认的一种设计模式-简单工厂"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_23个设计模式-默认的一种设计模式-简单工厂"}},[_._v("#")]),_._v(" 23个设计模式 + 默认的一种设计模式（简单工厂）")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[_._v("设计模式是为了解决软件开发中出现的同类问题，根据前人总结经得起时间考验的软件开发问题解决方案。\n设计模式分为三大类，主要解决软件开发中的，创建型问题、结构型问题、行为型问题\n每一种设计模式，都有对应的：应用场景、解决方案（设计思路、具体实现）\n\n不过每一种设计模式\n都有其存在的意义，也就相应的有其对应的优缺点，并不能说谁是最好的设计模式，只能说在需要解决的应用场景中，那种模式能够更好的解决问题。\n")])])]),v("h2",{attrs:{id:"创建型设计模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建型设计模式"}},[_._v("#")]),_._v(" 创建型设计模式")]),_._v(" "),v("h3",{attrs:{id:"_1-简单工厂"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-简单工厂"}},[_._v("#")]),_._v(" 1. 简单工厂")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[_._v('> 不是23种设计模式中的一种，只不过也算是很常用的一种设计模式，\n> 在软件开发中也经常能够看到，他上面还有两个大哥是属于23种设计模式的\n  \n>简单来说，这个模式就是，将类的创建和方法分开，而不是在同一个类进行，通过创建一个工厂类来进行类的创建也就是实例化。\n>具体一般使用这种设计模式都是因为，类的创建和方法使用在同一个类里面，让类的功能太过繁重，违反了单一职责，并且在进行扩展创建\n>不同的类的时候，需要重新修改类里面的源码，也违反了软件设计的"开闭原则"\n>\n')])])]),v("h3",{attrs:{id:"_2-工厂方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-工厂方法"}},[_._v("#")]),_._v(" 2. 工厂方法")]),_._v(" "),v("blockquote",[v("p",[_._v("工厂方法模式也成为工厂模式，属于23中设计模式的一种，是很多开源框架和api类库的核心设计模式，最常听说的比如\nbean工厂，spring框架里面用来创建bean的工厂就是工厂方法的一种实际应用。")])]),_._v(" "),v("blockquote",[v("p",[_._v("工厂方法模式的含义是：定义一个创建对象的接口，让子类来决定实例化哪一个类。工厂方法模式通过提供一个抽象的工厂接口，\n由子类工厂类决定实例化的具体产品类。")])]),_._v(" "),v("ul",[v("li",[_._v("优点")])]),_._v(" "),v("blockquote",[v("p",[_._v('主要优点应该是完美符合"开闭原则"，在需要增加新的产品时，只需要再实现一个具体产品和对应具体工厂即可，同时也契合封装的特性，让用户无需关心具体的实现\n细节，只需要选择需要创建对象的具体工厂类即可。')])]),_._v(" "),v("ul",[v("li",[_._v("缺点")])]),_._v(" "),v("blockquote",[v("p",[_._v("每次新增一个产品需要多增加一个具体实现类和具体工厂类，无疑让系统越来越庞大的同时，增加了系统的复杂性和理解成本")])]),_._v(" "),v("h3",{attrs:{id:"_3-抽象工厂"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-抽象工厂"}},[_._v("#")]),_._v(" 3. 抽象工厂")]),_._v(" "),v("blockquote",[v("p",[_._v("抽象工厂，某种程度上来说是为了解决工厂方法某些缺陷而产生的，因为对于一个可能拥有较多产品等级结构和产品族的需求，使用工厂方法模式\n无疑并不是一个很好的选择，需要对其进行一定层度上的优化，而降低其产生的复杂性。同时这也是很多开源框架api类库的常用设计模式，不过每一种设计模式\n都有其存在的意义，也就相应的有其对应的优缺点，并不能说谁是最好的设计模式，只能说在需要解决的应用场景中，那种模式能够更好的解决问题。")])]),_._v(" "),v("blockquote",[v("p",[_._v("抽象工厂的定义是：提供一个创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类。")])]),_._v(" "),v("ul",[v("li",[_._v("优点")])]),_._v(" "),v("blockquote",[v("p",[_._v("相对工厂方法而言将同一系列对象的创建封装在同一个工厂类里面，可以减少需要创建的具体工厂数量的同时，也降低系统的复杂度。")])]),_._v(" "),v("blockquote",[v("p",[_._v("当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。")])]),_._v(" "),v("blockquote",[v("p",[_._v("增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。")])]),_._v(" "),v("ul",[v("li",[_._v("缺点")])]),_._v(" "),v("blockquote",[v("p",[_._v("因为提前定义好了工厂所指定的具体产品类，在我们需要改动增加具体工厂里面的创建方法的时候，我们就不得不重新修改抽象工厂方法，这违反了\n“开闭原则”，抽象工厂模式的这种性质称为“开闭原则”的倾斜性")])]),_._v(" "),v("h3",{attrs:{id:"_4-单例模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-单例模式"}},[_._v("#")]),_._v(" 4. 单例模式")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[_._v("定义：一个类只有一个实例，并且提供全局访问点 \n")])])]),v("ul",[v("li",[_._v("应用场景：")])]),_._v(" "),v("blockquote",[v("p",[_._v("1.系统只需要一个实例对象，因为每次进行实例化的对象内容都是一致的，考虑到资源问题，所以可以使用单例模式.")])]),_._v(" "),v("blockquote",[v("p",[_._v("2.客户实用类的实例，只允许一个公共访问点，不允许通过其他途径访问")])]),_._v(" "),v("ul",[v("li",[_._v("实现方式：\n"),v("ol",[v("li",[_._v("懒汉模式，在使用到对应单例类才进行全局唯一单例的实例化，并提供全局访问点，因为是延迟加载，存在并发问题，处理不好容易导致出现多个实例对象")]),_._v(" "),v("li",[_._v("饿汉模式，在一开始就进行类加载的时候就进行实例化，虽然没有了并发问题，但是也因为一开始就进行实例化，减慢启动加载的同时，不进行使用的时候其实是存在一定资源利用率低问题的")]),_._v(" "),v("li",[_._v("静态内部类Initialization Demand Holder (IoDH)， 通过在单例对象类里面，增加一个静态类用来进行全局唯一实例的实例化，在调用到该类的时候才进行类加载\n其实是使用到的饿汉模式，只不过这种方式兼顾了懒汉模式延迟加载，提高资源利用率的优点")])])]),_._v(" "),v("li",[_._v("优点：\n节约资源，同时也可以防止不同实例出现数据不一致")]),_._v(" "),v("li",[_._v("缺点：\n单例类即承担了类工厂创建的功能也承担了使用的功能，某种程度来说违反了“单一职责”的原则，不过这个得结合实际情况讨论。")]),_._v(" "),v("li",[_._v("日常业务接触：其实枚举也是一种单例模式设计，在最初得时候没有枚举类，是通过自己实现一个单例模式枚举类来使用枚举的。Java5之后才有了枚举类型类")])]),_._v(" "),v("h3",{attrs:{id:"_5-原型模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-原型模式"}},[_._v("#")]),_._v(" 5.原型模式")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[_._v("定义：使用原型实例指定创建类的种类，并通过拷贝这个原型的属性，创建一个新的对象\n")])])]),v("ul",[v("li",[_._v("应用场景: 创建新对象的成本较大，比如说需要进行比较多的资源交互，其实需要的对象和原型对象的差别并不大")]),_._v(" "),v("li",[_._v("实现方式：\n"),v("ol",[v("li",[_._v("浅克隆，实现Cloneable接口，实现顶级父类object的clone方法来实现对象的克隆，只复制成员变量是值类型的成员变量，其他引用变量，只复制引用地址")]),_._v(" "),v("li",[_._v("深克隆， 通过序列化对象，将对象转换成输出流，然后再转化成输入流得到克隆的对象，会复制值类型的值和引用类型的对象")])])]),_._v(" "),v("li",[_._v("优点：当创建对象流程比较复杂时，可以提高创建对象的效率。")]),_._v(" "),v("li",[_._v("缺点：需要为每一个类配备一个克隆方法，当改动类时，需要需要修改源码，违背“开闭原则”，深度克隆时，每一层对象都需要支持深度克隆，提高系统复杂性")]),_._v(" "),v("li",[_._v("日常业务接触：日常接触较少，一般进行的是属性复制，不进行对象克隆。")])]),_._v(" "),v("h3",{attrs:{id:"_6-建造者模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-建造者模式"}},[_._v("#")]),_._v(" 6. 建造者模式")]),_._v(" "),v("blockquote",[v("p",[_._v("将一个复杂对象的构建和他的表现分离，使得其可以通过同样的构建过程可以创建不同的表示")])]),_._v(" "),v("ul",[v("li",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("需要生成的产品结构复杂，存在较多的属性")]),_._v(" "),v("li",[_._v("产品属性相互依赖，需要指定创建顺序")]),_._v(" "),v("li")]),_._v(" "),v("ul",[v("li",[_._v("实现方式：")])]),_._v(" "),v("ol",[v("li",[_._v("创建一个抽象的构建类，子类通过实现构建类，来指定不同的构建产品顺序和属性")])]),_._v(" "),v("ul",[v("li",[_._v("优点：")])]),_._v(" "),v("ol",[v("li",[_._v("每一个具体建造者都相对独立，与其他建造者不互相依赖，新增表示形式事只需要新增新的具体建造者无需修改原有代码，\n符合“开闭原则”。")]),_._v(" "),v("li",[_._v("其次可以更加精细的控制产品创建流程")])]),_._v(" "),v("ul",[v("li",[_._v("缺点：")])]),_._v(" "),v("ol",[v("li",[_._v("如果产品结构复杂，需要定义很多的具体建造者，无疑会增加系统的复杂性，理解难度和运行成本")]),_._v(" "),v("li",[_._v("其使用条件要求较高，使用有一定限制")])]),_._v(" "),v("ul",[v("li",[_._v("日常业务接触：")])]),_._v(" "),v("ol",[v("li",[_._v("比较类似的，比如项目中有一个消息模块，因为消息体构建起来较为复杂每个属性都需要独立设置也存在一定的依赖关系，所以简化了一下\n创建者模式，创建了一个消息构建器用来构建发布的消息")])]),_._v(" "),v("h2",{attrs:{id:"结构性设计模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#结构性设计模式"}},[_._v("#")]),_._v(" 结构性设计模式")]),_._v(" "),v("h3",{attrs:{id:"_7-适配器模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-适配器模式"}},[_._v("#")]),_._v(" 7.适配器模式")]),_._v(" "),v("blockquote",[v("p",[_._v("将一个接口转换成客户希望的另一个接口，使结构不兼容的类可以一起工作")])]),_._v(" "),v("ul",[v("li",[_._v("应用场景：")])]),_._v(" "),v("ol",[v("li",[_._v("想要将之前一些没有太大关联的类，联合起来一起工作")])]),_._v(" "),v("ul",[v("li",[_._v("实现方式：")])]),_._v(" "),v("ol",[v("li",[_._v("适配器模式有多种实现方式还分单向和双向，单项主要实现思想是继承对应需要转换的接口，实现另一个接口，将两个接口联通起来，双向是同时实现需要联通的两个接口")])]),_._v(" "),v("ul",[v("li",[_._v("优点：")])]),_._v(" "),v("ol",[v("li",[_._v("将目标类和适配者类进行解耦，无需修改原有结构")]),_._v(" "),v("li",[_._v("灵活性和扩展性都挺好的符合“开闭原则”")])]),_._v(" "),v("ul",[v("li",[_._v("缺点：")])]),_._v(" "),v("ol",[v("li",[_._v("对于Java等不支持多重继承的语言，一次只是适配一个类")]),_._v(" "),v("li",[_._v("有一定的局限性，类适配器模式中的目标抽象类只能为接口，不能为类")])]),_._v(" "),v("ul",[v("li",[_._v("日常业务接触：：日常接触较少这方面的业务")])]),_._v(" "),v("h3",{attrs:{id:"_8-桥接模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-桥接模式"}},[_._v("#")]),_._v(" 8. 桥接模式")]),_._v(" "),v("blockquote",[v("p",[_._v("定义：将抽象部分和它的实现部分分离，使得他们都可以进行独立的变化")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("应用场景：")])]),_._v(" "),v("li",[v("p",[_._v("实现方式：")])]),_._v(" "),v("li",[v("p",[_._v("优点：")])]),_._v(" "),v("li",[v("p",[_._v("缺点：")])]),_._v(" "),v("li",[v("p",[_._v("日常业务接触：")])])]),_._v(" "),v("h3",{attrs:{id:"设计模式模板"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#设计模式模板"}},[_._v("#")]),_._v(" 设计模式模板")]),_._v(" "),v("blockquote"),_._v(" "),v("ul",[v("li",[v("p",[_._v("应用场景：")])]),_._v(" "),v("li",[v("p",[_._v("实现方式：")])]),_._v(" "),v("li",[v("p",[_._v("优点：")])]),_._v(" "),v("li",[v("p",[_._v("缺点：")])]),_._v(" "),v("li",[v("p",[_._v("日常业务接触：")])])])])}),[],!1,null,null,null);v.default=t.exports}}]);