(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{393:function(v,_,l){"use strict";l.r(_);var i=l(2),n=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"运行时内存结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行时内存结构"}},[v._v("#")]),v._v(" 运行时内存结构")]),v._v(" "),_("p",[v._v("jvm运行时内存结构主要分为五个部分，分别是：程序计数器、虚拟机栈、本地方法栈、堆内存、方法区")]),v._v(" "),_("p",[v._v("线程私有：程序计数器、虚拟机栈、本地方法栈\n线程共享：堆内存、方法区 、堆外内存（Java7的永久代或JDK8的元空间、代码缓存）")]),v._v(" "),_("ol",[_("li",[v._v("程序计数器"),_("br"),v._v("\n程序计数器是一块较小的内存空间，可以看作是当前线程执所执行字节码所行的行号指示器。当cpu在多个线程中切换时，程序计数器会将下一行将执行字节码的行号记录下来，\n当cpu切换回来的时候，可以从记录位置开始恢复线程的执行")]),v._v(" "),_("li",[v._v("虚拟机栈"),_("br"),v._v("\n虚拟机栈，其实说的是Java方法执行时的内存模型，内部主要结构类似于一个栈帧管道，执行先入后出的原则，当线程执行到某一个方法是会创建一个栈帧，压入虚拟机栈。\n每个栈帧内部结构区分为：局部变量表、操作数栈、动态链接、返回地址、附加信息\n"),_("ul",[_("li",[v._v("局部变量表"),_("br"),v._v("\n主要作用是存储方法参数和定义在方法体内的局部变量，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。")]),v._v(" "),_("li",[v._v("操作数栈"),_("br"),v._v("\n主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新 PC 寄存器中下一条需要执行的字节码指令\n另外我们说Java虚拟机栈的解释引擎是基于栈的执行引擎，这里的栈指的就是操作数栈")]),v._v(" "),_("li",[v._v("动态链接"),_("br"),v._v("\n将符号引用转换为调用方法的直接引用")]),v._v(" "),_("li",[v._v("返回地址"),_("br"),v._v("\n用来存放调用该方法的 PC 寄存器的值。也就是记录执行到具体方法的那一步")]),v._v(" "),_("li",[v._v("附加信息"),_("br"),v._v("\n栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。")])])]),v._v(" "),_("li",[v._v("本地方法栈"),_("br"),v._v("\n虚拟机栈用来管理Java方法的调用，本地方法栈用来管理本地方法的调用，类似于虚拟机栈。本地方法并不是使用Java语言实现的，一般是c语言。")]),v._v(" "),_("li",[v._v("堆内存"),_("br"),v._v("\n堆内存是Java虚拟机管理内存中最大的一块，主要用来存放对象实例，被所有线程共享，在逻辑上被划分为三块区域，新生代、老年代、永久代（jdk1.8之后叫元空间）\n"),_("ul",[_("li",[_("p",[v._v("新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代")]),v._v(" "),_("ul",[_("li",[v._v("新生代又被划分为两个幸存者区域和一个伊甸区，空间大小分别是1：1：8")]),v._v(" "),_("li",[v._v("新创建的实例对象都存档在伊甸区，每次伊甸区填充对象会进行一个小GC将存活对象放大其中一个幸存者区")]),v._v(" "),_("li",[v._v("幸存者区同时只有一个区域存在对象，每次小GC都会将幸存者区域存储空间变换成另一个将之前存放对象的空间空出来")]),v._v(" "),_("li",[v._v("经过多次 GC 循环后存活下来的对象被移动到老年代，一般这个次数好像是15次")]),v._v(" "),_("li",[v._v("注意如果创建的对象需要很大的连续内存空间，会直接放入老年代，避免在伊甸区和幸存者区进行大量的内存拷贝")])])]),v._v(" "),_("li",[_("p",[v._v("老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大")]),v._v(" "),_("ul",[_("li",[v._v("主要存放经过多轮小型GC依旧存活的对象")]),v._v(" "),_("li",[v._v("老年代满了之后会进行垃圾收集，也就是主GC，通常需要更长时间")]),v._v(" "),_("li",[v._v("判断一个对象是否可回收方法大致有如下：\n"),_("ul",[_("li",[v._v("引用计数法")]),v._v(" "),_("li",[v._v("可达性分析")])])]),v._v(" "),_("li",[v._v("垃圾收集的方法大致有如下：\n"),_("ul",[_("li",[v._v("标记，清除，标记存活对象，然后清理其他未被标记的内存，这种方式容易产生大量的内存碎片")]),v._v(" "),_("li",[v._v("标记，整理，标记存活对象，让所有存活对象往一个方向移动，然后清理对象边界以外的内存")]),v._v(" "),_("li",[v._v("复制，将内存分为两块，只使用其中一块，将存活对象复制到另一块，清理之前使用的内存块")])])])])]),v._v(" "),_("li",[_("p",[v._v("堆内存使用的垃圾回收算法是：分代收集算法。将堆内存分为新生代、老年代")]),v._v(" "),_("ul",[_("li",[v._v("新生代：使用复制算法")]),v._v(" "),_("li",[v._v("老年代：使用标记清除亦或者标记整理算法")])])]),v._v(" "),_("li",[_("p",[v._v("元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存，其实这一块就是我们接下来要将的方法区，因为这一块内存还有一个别名Non-Heap（非堆），\n其目的应该就是要与堆内存分离开来，所以这一块在下面进行解释")])])])]),v._v(" "),_("li",[v._v("方法区"),_("br"),v._v("\n方法区与堆一样是线程共享的，它还有一个别名Non-Heap(非堆)，Java虚拟机规范把方法区描述为堆的一个逻辑部分。运行时常量池也是方法区的一部分，jvm关闭的时候方法区即释放。\n方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。")])]),v._v(" "),_("ul",[_("li",[v._v("方法区，只是jvm规范中定义的一个概念，用来存储，类信息、常量池、静态变量、jit编译后的代码等数据")]),v._v(" "),_("li",[v._v("方法区的内部结构：类型信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据")])])])}),[],!1,null,null,null);_.default=n.exports}}]);